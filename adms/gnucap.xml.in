<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">
<!-- version: not renamed, load: renamed fname -->

<!-- *********************************************************************************** -->
<!-- ******************************** global settings ********************************** -->
<!-- *********************************************************************************** -->

<!-- output filename is 1st argument in -o flag in command line-->
<admst:variable name="filename" select="%(/module/name)_common"/>
<admst:variable name="filename_state" select="0"/>
<admst:for-each select="/argv">
	<admst:variable name="arg" select="%(.)"/>
	
	<admst:if test="[position(.)=2]">
		<admst:variable name="filename" select="$arg"/>
	</admst:if>
	<admst:if test="[$(filename_state)='1']">
		<admst:variable name="filename" select="$arg"/>
		<admst:variable name="filename_state" select="2"/>
	</admst:if>
	<admst:if test="[$(filename_state)='0' and $(arg)='-o']">
		<admst:variable name="filename_state" select="1"/>
	</admst:if>	
</admst:for-each>

<!-- prefix for local variables -->
<admst:variable name="var_prefix" select="__"/>
<admst:variable name="node_prefix" select="n_"/>
<admst:variable name="state_prefix" select="ddt_"/>
<admst:variable name="ddt_type" select="x_"/>

<!-- variables used by tree traverse (by guesstopology?) -->
<admst:variable name="localvariables"/>
<admst:variable name="ddt_cur" select="0"/>

<!-- variables used by tree traverse for hxx -->
<admst:variable name="_DYNAMIC" select="yes"/>
<admst:variable name="_STATIC" select="yes"/>
<admst:variable name="_DERIVATE" select="yes"/>
<admst:variable name="_DERIVATE2" select="yes"/>
<admst:variable name="_DERIVATEFORDDX" select="yes"/>
<admst:variable name="_DDX" select="yes"/>
<admst:variable name="eval_mode"/> <!-- ac, tr, dc?, ... -->
<admst:variable name="tr_begin"/>

<admst:variable name="requiredderivateforddx" select="no"/>
<admst:variable name="SkipFVariable" select="n"/>
<admst:variable name="ddxinsidederivate" select="no"/>
<admst:variable name="SkipFVariable" select="n"/>
<admst:variable name="pprobe"/>
<admst:variable name="qprobe"/>
<admst:variable name="e"/>
<admst:variable name="ep"/>
<admst:variable name="eq"/>
<admst:variable name="epq"/>
<admst:variable name="keep_ic" select="no"/>
<admst:variable name="eval_kept" select="no"/>
<admst:variable name="globalanalogfunction"/>
<admst:variable name="finddt" select="no"/>

<!-- result for tree traverse (ngspiceVersion vs .hxx) -->
<admst:variable name="str_res_version" select=""/>
<admst:variable name="str_res_hxx_ac" select=""/>
<admst:variable name="str_res_hxx_tr" select=""/>

<!-- noise -->
<admst:value-to select="/simulator/package_name" value="fucap"/>
<admst:value-to select="/simulator/package_tarname" value="fucap"/>
<admst:value-to select="/simulator/package_version" value="0.0.0.1"/>
<admst:value-to select="/simulator/package_string" value="fucap 0.0.0.1"/>
<admst:value-to select="/simulator/package_bugreport" value="felix@em.cs"/>
<admst:for-each select="/module">
	<admst:new datatype="list" arguments="fnoise"><admst:variable name="fnoise" select="%(.)"/></admst:new>
	<admst:new datatype="list" arguments="tnoise"><admst:variable name="tnoise" select="%(.)"/></admst:new>
	<admst:new datatype="list" arguments="wnoise"><admst:variable name="wnoise" select="%(.)"/></admst:new>
	<admst:for-each select="contribution">
		<admst:variable name="contribution" select="%(.)"/>
		<admst:variable name="dependency" select="%(math/dependency)"/>
		<admst:choose>
		<admst:when test="rhs/tree/adms[datatypename='function']/..[name='flicker_noise']"><admst:push into="$fnoise/item" select="$contribution" onduplicate="ignore"/></admst:when>
		<admst:when test="[$dependency='constant']/rhs/tree/adms[datatypename='function']/..[name='white_noise']"><admst:push into="$tnoise/item" select="$contribution" onduplicate="ignore"/></admst:when>
		<admst:when test="[$dependency!='constant']/rhs/tree/adms[datatypename='function']/..[name='white_noise']"><admst:push into="$wnoise/item" select="$contribution" onduplicate="ignore"/></admst:when>
		</admst:choose>
	</admst:for-each>
</admst:for-each>

<!-- create attribute with module name -->
<admst:for-each select="/module">
	<admst:new datatype="attribute" arguments="ngspicename">
	<admst:push into="../attribute" select="." onduplicate="abort"/>
	<admst:value-of select="../name"/>
	<admst:value-to select="value" value="%s"/>
	</admst:new>
</admst:for-each>


<!-- *********************************************************************************** -->
<!-- *********************************** my utils ************************************** -->
<!-- *********************************************************************************** -->

<admst:variable  name="myF_par1" select=""/>
<admst:variable  name="myF_par2" select=""/>
<admst:variable  name="myF_ret1" select=""/>


<admst:template match="utils_compare_nodes_position">
<admst:message test="[/dbg_xml='yes']" format="*utils_compare_nodes_position*\n"/>
	<admst:variable  name="myF_ret1" select="not_found"/>
	
	<admst:if test="[$(myF_par1)=$(myF_par2)]">
		<admst:variable  name="myF_ret1" select="equal"/>
	</admst:if>

	<admst:for-each select="node[grounded='no']">
		<admst:variable name="local_name" select="%(name)"/>
		<admst:if test="[$myF_ret1='not_found']">
			<admst:if test="[$myF_par1=$local_name]">
				<admst:variable  name="myF_ret1" select="smaller"/>
			</admst:if>
			<admst:if test="[$myF_par2=$local_name]">
				<admst:variable  name="myF_ret1" select="bigger"/>
			</admst:if>			
		</admst:if>	
	</admst:for-each>
</admst:template>


<!-- *********************************************************************************** -->
<!-- ************************************** Make File .h ******************************* -->
<!-- *********************************************************************************** -->

<admst:open file="$(filename).h">
#include <stdio.h>
#include  "math.h"

#include "u_xprobe.h"
#include "d_subckt.h"
#include "e_storag.h"
#include "e_model.h"
#include "e_adms.h"
#include "u_parameter.h"

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:variable name="module" select="%s"/>
  <admst:variable name="DEV_NAME" select="DEV_%(upper-case(name))"/>
  <admst:variable name="MODEL_NAME" select="MODEL_%(upper-case(name))"/>
#ifndef $(module)_header__
#define $(module)_header__

// customization - gnucap specific constants
#define VALUE_NAME "#"
#define TAIL_SIZE 1
#define _DDX
#define _DERIVATEFORDDX

#define SPICE_LETTER "\0"
#define DEVICE_TYPE "dev_$(module)"
#define MODEL_TYPE "$(module)"
#define _N(n) _n[$(node_prefix) ## n]

#define MIN_NET_NODES 0
#define MAX_NET_NODES %(count(node[grounded='no' and location='external']))
#define INTERNAL_NODES %(count(node[grounded='no' and location='internal']))

#define NP(p) min(100.,max(-100., _N(p).v0()) )
#define BP(p,n) (BP2( $node_prefix ## p, $node_prefix ## n ))

<admst:text format="static std::string port_names[] = {"/>
<admst:join select="node[grounded='no' and location='external']" separator=", ">
   	<admst:value-of select="name"/>  
   	<admst:text format="&quot;%s&quot;"/>    
</admst:join>
<admst:text format="};"/>

#define CONSTCtoK (273.15) // also in gnucap/constans.h P_CELSIUS0

#define EXIT_IF_ISNAN(var) \
	if(isnan((double) var)) {printf("%%s:%%i:isnan:"#var"\n",__FILE__,__LINE__);exit(1);} \
	if(isinf((double) var)) {printf("%%s:%%i:isinf:"#var"\n",__FILE__,__LINE__);exit(1);}

        inline void _used(double)  {}        



class $(DEV_NAME);
class $(MODEL_NAME) : public MODEL_CARD {  
	
protected:
	explicit $(MODEL_NAME)(const $(MODEL_NAME)& p);	// for clone
public:
	explicit $(MODEL_NAME)(const $(DEV_NAME)* p);	// for dispatcher
~$(MODEL_NAME)();
public: // override virtual
	MODEL_CARD* clone()const {return new $(MODEL_NAME)(*this);}

	void precalc_first();

public: // type
	void set_dev_type(const std::string& nt);
	std::string dev_type()const	{ return _key;}

public: // parameters
	int param_count_dont_print() const;
	int param_count() const;
	bool param_is_printable(int i) const;	
	std::string param_name(int i) const;
	std::string param_name(int i, int j)const;
	std::string param_value(int i) const; 
	void set_param_by_index(int, std::string&, int);	
	void Set_param_by_name(std::string Name, std::string Value);
	bool IsParamGiven(const char *name) const;

public:	
	// verilog - parameters
	<admst:for-each select="variable[input='yes']">
          <admst:choose>
            <admst:when test="[type='real']">
              <admst:text format="\n\tPARAMETER&lt;double&gt; %(.);"/>
            </admst:when>
            <admst:when test="[type='integer']">
              <admst:text format="\n\tPARAMETER&lt;int&gt; %(.);"/>
            </admst:when>
            <admst:otherwise>
              <admst:fatal format="type of verilog-parameter is not real or interger\n"/>
            </admst:otherwise>
          </admst:choose>
	</admst:for-each>

	// verilog - variables (all with scope 'global_model' i.e. have 'ask' field)
	<admst:for-each select="variable[input='no' and scope='global_model']">
	  <admst:choose>
		<admst:when test="[type='real']">
		  <admst:text format="\n\tdouble %(.);"/>
		</admst:when>
		<admst:when test="[type='integer']">
		  <admst:text format="\n\tint %(.);"/>
		</admst:when>
		<admst:otherwise>
		  <admst:text format="\n\tstd::string %(.);"/>
		</admst:otherwise>
	  </admst:choose>
	</admst:for-each>

public:
	std::string _key;
	std::string _level;
    PARAM_LIST  _params;
};

/* ========================================================= */

class $(DEV_NAME) : public ADMS_BASE 
{
  private:	
    std::string _modelname;
    const $(MODEL_NAME)* _model;
    node_t _nodes[ %(count(node[grounded='no'])) ];

  private:
    unsigned current_state;
    unsigned _next_state(){  current_state++;  assert (current_state<=_num_states); 
                return current_state-1; } 


private:
	explicit $(DEV_NAME)(const $(DEV_NAME)& p);
public:
	explicit $(DEV_NAME)();
	~$(DEV_NAME)();

protected: // override virtual
	char id_letter()const	{untested();return SPICE_LETTER[0];}
	bool print_type_in_spice()const {return true;}
	std::string value_name()const {return VALUE_NAME;}
	uint_t max_nodes()const {return MAX_NET_NODES;}
	uint_t min_nodes()const {return MIN_NET_NODES;}
	uint_t matrix_nodes()const {return %(count(node[grounded='no']));}
	uint_t net_nodes()const {return _net_nodes;}
	uint_t int_nodes()const {return INTERNAL_NODES;}
	CARD* clone()const {return new $(DEV_NAME)(*this);}
	
	void precalc_first();
	void expand();
	void precalc_last();
	void internal_precalc();

	// tr
	void tr_call_iwants(int m_1, int m_2);
	void tr_iwant_matrix();
        void tr_begin();
        const $(MODEL_NAME)* model(){
          //FIXME fetch model from COMMON
          //const COMMON_COMPONENT* c = asserted_cast<const COMMON_COMPONENT*>(common());
          // const $(MODEL_NAME)* m = prechecked_cast<const $(MODEL_NAME)*>(c->model());

            const $(MODEL_NAME)* m = prechecked_cast<const $(MODEL_NAME)*>(_model);
              return m;
      }


	void tr_restore() {ADMS_BASE::tr_restore(); internal_precalc();}
        void store_values();
        void dc_advance();
	void tr_advance();
	void tr_regress();
	bool tr_needs_eval()const;	
	bool do_tr();
	void tr_load();
	void tr_eval();
	void tr_eval_kept();
        bool conv_check()const;
	TIME_PAIR tr_review();
	void tr_accept();
	void tr_unload();
	double tr_involts()const	{unreachable();return NOT_VALID;}	
	double tr_involts_limited()const {unreachable();return NOT_VALID;}	
	double tr_amps()const	{itested();return NOT_VALID;}
	double tr_probe_num(const std::string&)const;

	// ac
	void ac_iwant_matrix();
	void ac_begin();
	void do_ac();
        void ac_eval(); // -> COMMON?
	void ac_load();
	COMPLEX ac_involts()const {unreachable();return NOT_VALID;}
	COMPLEX ac_amps()const {unreachable();return NOT_VALID;}
	XPROBE  ac_probe_ext(const std::string&)const {itested(); return XPROBE(NOT_VALID, mtNONE);}
	uint_t tail_size()const {return TAIL_SIZE;}

	//misc
	void keep_ic();
	bool has_memory(){return _num_states;}
	
public:	// ports
	std::string port_name(uint_t i)const {
		itested();
		assert(i < MAX_NET_NODES);
		return port_names[i];
	}
	
public:	// type
	void set_dev_type(const std::string& nt);
	std::string dev_type()const	{return _modelname;}
	
private: // parameters
	void set_param_by_name(std::string Name, std::string Value);
	void Set_param_by_name(std::string Name, std::string Value);
	void Set_param_by_index(int, std::string&, int);
	int param_count_dont_print()const {return common()->COMMON_COMPONENT::param_count();}

protected: // implementation
	void guesstopology();
	void acLoad();
	void pzLoad(COMPLEX s);
	enum ELoadModes {
		MODE = 0x3, 				// old 'mode'
		MODETRAN = 0x1,
		MODEAC = 0x2,
		MODEDC = 0x70,				// old 'modedc'
		MODEDCOP = 0x10,
		MODETRANOP = 0x20,
		MODEDCTRANCURVE = 0x40,
		INITF = 0x3f00,				// old 'initf' parameters
		MODEINITFLOAT = 0x100,
		MODEINITJCT = 0x200,
		MODEINITFIX = 0x400,
		MODEINITSMSIG = 0x800,
		MODEINITTRAN = 0x1000,
		MODEINITPRED = 0x2000,
		MODEUIC = 0x10000l		// old 'nosolv' paramater
	};
	int load(int mode);

private: // verilog - variables (all with scope "global_instance" eq. have 'ask' field)
	<admst:for-each select="variable[input='no' and scope='global_instance']">
	<admst:choose>
          <admst:when test="[type='real']"><admst:text format="\n\tdouble $(var_prefix)%(.);"/></admst:when>
          <admst:when test="[type='integer']"><admst:text format="\n\tint $(var_prefix)%(.);"/></admst:when>
          <admst:otherwise><admst:text format="\n\tstd::string $(var_prefix)%(.);"/></admst:otherwise>
	</admst:choose>
	</admst:for-each>

private: // analogfunctions of verilog-modul

	<admst:apply-templates select="/module" match="analogfunctionH"/>

private: // nodes / matrix indexes

	public:

	<admst:text format="\tenum ENodes {"/>
  	<admst:join select="node[grounded='no']" separator=",">
    	<admst:value-of select="name"/>  
    	<admst:text format=" $node_prefix%s=%(position(.)-1)"/>
	<admst:text test="[position(.)=count(.)]" format=", _num_total_nodes=%(count(.))"/>

  	</admst:join>
	<admst:text format=" };"/>

	private:
	double BP2(  ENodes p,  ENodes n  ) const;
	double it0[_num_total_nodes];
	double it1[_num_total_nodes];
	double i_kept[_num_total_nodes];
	
	enum EMatrixEntries {
	<admst:variable name="local_var" select="II"/>
	<admst:for-each select="jacobian">
          <admst:value-of select="column/name"/>
          <admst:value-of select="row/name"/>
          <admst:text format="\tm_%s_%s=%(position(.)-1)"/>

          <admst:variable name="local_var" select="$(local_var)I"/>
          <admst:if test="[position(.)!=count(.)]">
            <admst:text format=", "/>
            <admst:if test="[$(local_var)='IIIIIII']">
              <admst:variable name="local_var" select="I"/>
              <admst:text format="\n\t"/>
            </admst:if>	
          </admst:if>
          <admst:if test="[position(.)=count(.)]">
            <admst:text format=" };"/>
          </admst:if>	
    </admst:for-each>

	// what is this?
	bool m_required[%(count(jacobian))];

	double m_entries[%(count(jacobian))];
	double m_entries_old[%(count(jacobian))];
	double m_entries_kept[%(count(jacobian))]; // keep_ic, uic etc.

	// states FIXME

		enum EStates_branch_old {
        <admst:join select="source[dynamic='yes']" separator=", ">
                <admst:value-of select="branch/nnode/name"/>
                <admst:value-of select="branch/pnode/name"/>
                <admst:text format="state_%s_%s=%((position(.)-1)*2)"/>
        </admst:join>
        <admst:text format=" };\n"/>



        // we could use plain numbers as identifiers, but what would reduce
        // future flexibility/readability.
		enum EStates {

        <admst:variable name="numddt" select="0"/>
        <admst:for-each select="expression"> 
          <!--admst:message format="counting ddt $numddt in %(.)\n"/-->
               <admst:apply-templates select="tree" match="ddtcounter"/>
               <admst:for-each select="tree"> 
               </admst:for-each>
           </admst:for-each>
        <admst:variable name="_num_states" select="$numddt"/>

        <!--  <admst:apply-templates select="analog/code[datatypename='block']" match="find_ddt_states"/> -->
          _num_states = $numddt // a bit hackish, but adms cannot add.

			 };

        unsigned num_ddt(){return $numddt;}

        <admst:variable name="finddt" select="no"/>

	double* _states[OPT::_keep_time_steps]; // for each step: q0,i0, q1,i1, q2,i2, etc.
	double* _states_q1;	// for step t1:  q0, q1, q2, q3, etc.
	double* _states_kept;

        //even states: _y
        // odd states: _i
	
	double _DDT(double qq, unsigned stateno){
		_states[0][stateno*2]=qq;
		int qcap = stateno*2;

		trace1("$(DEV_NAME)::_DDT, qcap=", qcap);
		assert(_dt != 0.0);
		METHOD method;
		if( (_time[1]!=0) && (_method_a==mTRAP) ) method = mTRAP;
		else method = mEULER;

		std::valarray<FPOLY1> q(OPT::_keep_time_steps);
		std::valarray<FPOLY1> i(OPT::_keep_time_steps);

		unsigned k = OPT::_keep_time_steps;
		// stupid copy. fixme.
		// gnucap stores things more usable.

		for (unsigned ii = 0; ii < k; ii++)
		{
			trace5("$(DEV_NAME)::_DDT", ii, _states[ii][qcap], _states[ii][qcap+1], _time[0], _time[1] );
			assert( _states[ii][qcap] == _states[ii][qcap] );
			assert( _states[ii][qcap+1] == _states[ii][qcap+1] );
			q[ii] = FPOLY1(NOT_VALID, _states[ii][qcap], 0.0);
			i[ii] = FPOLY1(NOT_VALID, _states[ii][qcap+1], 0.0);// not necessary for ii==0
		}

		i[0] = differentiate(&q[0], &i[0], _time, method);
		trace3("differentiate", _time[0], method, i[0].f0);
		assert(i[0].f0 == i[0].f0);
		assert(i[0].f1 == i[0].f1);

		_states[0][qcap+1] = i[0].f0;

		if( _sim->analysis_is_static() )
		{
			assert(i[0].f0 == 0.0);
			return(0);
		}
		else
			untested();

		return i[0].f0;
	}

	void CKTterr(int qcap, double *time_step);	
	
	// noise: something is calculated, but never used
	<admst:text select="$fnoise/item" format="\n\tdouble fpnoise%(index($fnoise/item,.)), fenoise%(index($fnoise/item,.));"/>
	<admst:text select="$tnoise/item" format="\n\tdouble tnoise%(index($tnoise/item,.));"/>
        <admst:text select="$wnoise/item" format="\n\tdouble wnoise%(index($wnoise/item,.));"/>

};

inline double $(DEV_NAME)::BP2( $(DEV_NAME)::ENodes p,  $(DEV_NAME)::ENodes n  ) const{
	assert(is_number( _n[p].v0() - _n[n].v0() ));
	return  min( 100. , max (  _n[p].v0() - _n[n].v0(), -100. ));
}
</admst:for-each>

<admst:apply-templates select="." match="PrintHxxFunctions"/>

#endif
// vim should work with any ts=sw

</admst:open>


<!-- *********************************************************************************** -->
<!-- *********************************** Make d_*.cc *********************************** -->
<!-- *********************************************************************************** -->

<admst:template match="ddtcounter">
<admst:message test="[/dbg_xml='yes']" format="*ddtcounter*\n"/>
  <admst:if test="[(adms/datatypename)='function' and name='ddt']">
    <admst:variable name="numddt" select="$numddt+1"/>
    <admst:text format="\t\t\t_ddt_%(adms/id(.)), // %(.)\n"/>
  </admst:if>

  <admst:if test="[datatypename='mapply_unary'
    or datatypename='mapply_binary' or datatypename='mapply_ternary']">
    <admst:apply-templates select="arg1" match="ddtcounter"/>
  </admst:if>
  <admst:if test="[datatypename='mapply_binary' or datatypename='mapply_ternary']">
    <admst:apply-templates select="arg2" match="ddtcounter"/>
  </admst:if>
  <admst:if test="[datatypename='mapply_ternary']">
    <admst:apply-templates select="arg3" match="ddtcounter"/>
  </admst:if>
</admst:template>


<admst:open file="$(filename).cc">
/* AUTOMATICALLY GENERATED BY ADMS-XML
 * brought to you by Andreas Froese,
 *                   Felix Salfelder
 * do not edit
 */
#include <limits>

#include "$(filename).h"
#include "e_adms.h"
<admst:for-each select="/module">

//analog function stuff

<!--	<admst:apply-templates select="." match="c:math_h"/> -->

<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>
<admst:variable name="DEV_NAME" select="DEV_%(upper-case(name))"/>
<admst:variable name="MODEL_NAME" select="MODEL_%(upper-case(name))"/>
static COMMON_SUBCKT Default_Params(CC_STATIC);

static $(DEV_NAME) p0;
static DISPATCHER<CARD>::INSTALL d0(&device_dispatcher, DEVICE_TYPE, &p0);

static $(MODEL_NAME) p1(&p0);
static DISPATCHER<MODEL_CARD>::INSTALL d1(&model_dispatcher, MODEL_TYPE, &p1);

// ********************************* $(MODEL_NAME) ********************************* //
$(MODEL_NAME)::$(MODEL_NAME)(const $(DEV_NAME)* p) 
	:MODEL_CARD(p),
	<!-- output='yes' - no matter, parametertype=instance or module - no matter also -->
	<admst:for-each select="variable[input='yes']">
	<admst:apply-templates select="default/tree" match="stringify_expression"/>
	%(name)(%s),
	</admst:for-each>
	_key("dev_$(module)"),
	_level(),
	_params()
{	
}
// -------------------------------------------------------------------------- //
$(MODEL_NAME)::$(MODEL_NAME)(const $(MODEL_NAME)& p)
  :MODEL_CARD(p),
  	<admst:for-each select="variable[input='yes']">
	%(name)(p.%(name)),
	</admst:for-each>
   _key(p._key),
   _level(p._level),
   _params(p._params)
{
}
// -------------------------------------------------------------------------- //
$(MODEL_NAME)::~$(MODEL_NAME)()
{
  
}
// -------------------------------------------------------------------------- //
int $(MODEL_NAME)::param_count_dont_print() const 
{
	return(0);
}
// -------------------------------------------------------------------------- //
int $(MODEL_NAME)::param_count() const
{
	return(%(count(variable[input='yes'])));
}
// -------------------------------------------------------------------------- //
bool $(MODEL_NAME)::param_is_printable(int) const
{	
	return(true);
}
// -------------------------------------------------------------------------- //
std::string $(MODEL_NAME)::param_name(int i)const
{
	switch(i)
	{
		<admst:for-each select="variable[input='yes']">
		case %(position(.)-1): return("%(name)");
		</admst:for-each>
		default: return("");
	}
	return("");
}
// -------------------------------------------------------------------------- //
std::string $(MODEL_NAME)::param_name(int i, int j)const
{
	if( j == 0 ) return(param_name(i));
	return("");
}
// -------------------------------------------------------------------------- //
std::string $(MODEL_NAME)::param_value(int i) const
{
	switch(i)
	{
		<admst:for-each select="variable[input='yes']">
		case %(position(.)-1): return(%(name).string());
		</admst:for-each>
		default: return("");
	}
	return("");
}
// -------------------------------------------------------------------------- //
void $(MODEL_NAME)::set_param_by_index(int i, std::string& value, int offset)
{
	switch(i)
	{
		<admst:for-each select="variable[input='yes']">
		case %(position(.)-1): %(name)=value; break;
		</admst:for-each>
		default: throw Exception_Too_Many(i, %(count(variable[input='yes'])), offset); break;
	}
}
// -------------------------------------------------------------------------- //
void $(MODEL_NAME)::Set_param_by_name(std::string name, std::string value)
{
	<admst:for-each select="variable[input='yes']">
	if( name == "%(name)" ) {%(name)=value;return;}
	</admst:for-each>
	throw Exception_No_Match((std::string)__FILE__ + ": set_param_by_name: there is no parameter in $(MODEL_NAME) with such name:" + name);
}

bool $(MODEL_NAME)::IsParamGiven(const char* ) const
{
	return(false);
}
// -------------------------------------------------------------------------- //
void $(MODEL_NAME)::precalc_first()
{
	MODEL_CARD::precalc_first();

	const CARD_LIST* par_scope = scope();
	assert(par_scope);
	MODEL_CARD::precalc_first();
	<admst:for-each select="variable[input='yes']">
		<admst:apply-templates select="default/tree" match="stringify_expression"/>
		<admst:choose>
			<admst:when test="[type='real']"><admst:text format="\n\te_val(&amp;(this-&gt;%(name)), (double)%s, par_scope);"/></admst:when>
			<admst:when test="[type='integer']"><admst:text format="\n\te_val(&amp;(this-&gt;%(name)), (int)%s, par_scope);"/></admst:when>
		</admst:choose>
	</admst:for-each>
	
	// @(initial_model) block
	$(MODEL_NAME) *_model = this;
	 <admst:apply-templates select="analog" match="analog:initial_model" required="yes"/>
}
// -------------------------------------------------------------------------- //
void $(MODEL_NAME)::set_dev_type(const std::string& new_type)
{
	std::string s = short_label();
	char* p = new char[s.length()+1]; //BUG//memory leak
	s.copy(p, std::string::npos);
	p[s.length()] = '\0';
	
	std::cout << "overwriting dev_type\n";
	_key = new_type;
	if (OPT::case_insensitive) 
		notstd::to_lower(&_key);
}
// ********************************* $(DEV_NAME) ********************************* //
$(DEV_NAME)::$(DEV_NAME)()
  :ADMS_BASE(),   
   _modelname(""),
   _model(NULL),
   _nodes(),
	_states_q1(NULL)
 //  _states_1(NULL)
{
	std::fill_n(m_entries, %(count(jacobian)), 0);
	std::fill_n(m_entries_old, %(count(jacobian)), 0);

	attach_common(&Default_Params);
   
	_n = _nodes;
	for (unsigned ii = 0; ii < matrix_nodes(); ++ii)
		assert(!(_n[ii].n_()));


        for (int ii=0; ii<OPT::_keep_time_steps; ++ii){
          // not here!
          _states[ii] = NULL;
        }  
}
// -------------------------------------------------------------------------- //
$(DEV_NAME)::$(DEV_NAME)(const $(DEV_NAME)& p)
  :ADMS_BASE(p),
   _modelname(p._modelname),
   _model(p._model),
   _nodes(),
	_states_q1(NULL)
//   _states_1(NULL)
   /// _num_ddts(p._num_ddts), static...
   /// _num_states(p._num_states) static...
{
	std::fill_n(m_entries, %(count(jacobian)), 0);
	std::fill_n(m_entries_old, %(count(jacobian)), 0);

	for (int ii=0; ii<OPT::_keep_time_steps; ++ii){
		// not here!
		_states[ii] = NULL;
	}  

        
	
	_n = _nodes;
  	for (unsigned ii = 0; ii < matrix_nodes(); ++ii)
    	_n[ii] = p._n[ii];

  	for (int ii=0; ii<OPT::_keep_time_steps; ++ii)
  		_states[ii] = NULL;
}
// -------------------------------------------------------------------------- //
$(DEV_NAME)::~$(DEV_NAME)()
{
#if ($_num_states)
	if (_states[0]) {
		trace1("cleaning up states", long_label());
		for (int ii=0; ii<OPT::_keep_time_steps; ++ii) {
			trace1("cleaning up states", ii);
			assert(_states[ii]);
			delete [] _states[ii];
			_states[ii] = 0;
		}

		assert(_states_q1);
		delete[] _states_q1;

	} else {    
    //BUG! OPT::_keep_time_steps could have changed....
    for (int ii=0; ii<OPT::_keep_time_steps; ++ii) 
      assert(!_states[ii]);   
	assert(!_states_q1);
	}

#endif
}
// ---------------- all analog functions from verilog-module here: ---------- //

<admst:apply-templates select="/module" match="analogfunctionC"/>
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::set_dev_type(const std::string& new_type)
{
   std::cerr << "setting modelname " << new_type << "\n";
	_modelname = new_type;
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::Set_param_by_name(std::string /*Name*/, std::string /*new_value*/)
{
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::set_param_by_name(std::string /*Name*/, std::string /*Value*/)
{
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::Set_param_by_index(int /*i*/, std::string& /*new_value*/, int /*offset*/)
{
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::expand()
{
  trace2("$(DEV_NAME)::expand", _modelname,OPT::_keep_time_steps);
  ADMS_BASE::expand();

  if (!subckt()) {
    new_subckt();
  }else{
  }

  // attach model?! FIXME
  _model = dynamic_cast<const $(MODEL_NAME)*>(find_model(_modelname));
  if (!_model) 
    throw Exception_Model_Type_Mismatch(long_label(), _modelname, DEVICE_TYPE);

    // something like this.  
    // attach_model(_model);


  // set m_required
  guesstopology();
  // allocate state vectors

#if ($_num_states)
  if (!_states[0]) {
    // initialise in tr_begin() ?
    for (int ii=0; ii<OPT::_keep_time_steps; ++ii)  // >
    {
      assert(!_states[ii]);
      _states[ii] = new double[_num_states*2];
    }
    //assert(!_states_1);
    //_states_1 = new double[_num_states*2];

	assert(!_states_q1);
	_states_q1 = new double[_num_states];
	

  } else {
    for (int ii=0; ii<OPT::_keep_time_steps; ++ii) //>
            assert(_states[ii]);
//    assert(_states_1);
	assert(_states_q1);
  }
#endif


	std::fill_n(it1, (int)_num_total_nodes, 0);

	// fix up internal nodes
	if (_sim->is_first_expand()) {
		std::string node_names[] = {
         	<admst:join select="node[grounded='no']" separator=", ">  
					<admst:value-of select="name"/>  
					<admst:text format="&quot;%s&quot;"/>    
          	</admst:join>
				};
		trace4("DEV_ADMS::expand nodes",  net_nodes() , max_nodes() , matrix_nodes(), int_nodes());
		//		char fake_name[] = "a"; // FIXME: use real name
		for(unsigned ii = net_nodes(); ii < matrix_nodes(); ++ii) {
			if( !_n[ii].n_() ) {       
				trace1("alloc internal node ", ii);
				//_n[ii].new_model_node('.' + long_label() + '.' + fake_name, this);
				_n[ii].new_model_node(node_names[ii], this);
			}
			//++(*fake_name);
		}

	   // int start_internal = 0;
		for (unsigned ii = net_nodes(); ii < max_nodes(); ++ii){
			trace1("DEV_ADMS::expand grounding", ii);
			_n[ii].set_to_ground(this);
		}
		
		assert(max_nodes() != 0);		
		for (unsigned ii = 0; ii < matrix_nodes(); ++ii)
		{
			trace1("DEV_ADMS::expand matrix node check", ii);
			assert(_n[ii].n_());
		}
	}
	else
	untested();
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::precalc_first()
{
	ADMS_BASE::precalc_first();

        // push down parameters into spice data
        // BUG BUG BUG, dont use mutable_common here!!!1
	COMMON_SUBCKT* c = asserted_cast<COMMON_SUBCKT*>(mutable_common());
	assert(c);
	for (PARAM_LIST::iterator i = c->_params.begin(); i != c->_params.end(); ++i) 	
		if (i->second.has_hard_value()) 
			try 
			{
				Set_param_by_name(i->first, to_string(i->second.e_val(1,scope())));			
			}
			catch (Exception_No_Match&) 
			{
				error(bTRACE, long_label() + ": bad parameter: " + i->first + ", ignoring\n");
			}
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::precalc_last()
{
	assert(_model);
	ADMS_BASE::precalc_last();
	assert(!is_constant());
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::internal_precalc()
{
  trace1(" $(DEV_NAME)::internal_precalc()", long_label());
  
#define _STATIC
#define _DYNAMIC
  <admst:apply-templates select="analog" match="analog:initial_instance" required="yes"/>
#undef _STATIC
#undef _DYNAMIC

  set_converged(); 
  assert(!is_constant());
}
// -------------------------------------------------------------------------- //
void inline $(DEV_NAME)::tr_call_iwants(int m_1, int m_2)
{
	_sim->_aa.iwant(m_1, m_2);
	_sim->_lu.iwant(m_1, m_2);
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::tr_iwant_matrix()
{
	<admst:for-each select="jacobian">
		<admst:variable  name="myF_par1" select="%(row/name)"/>
		<admst:variable  name="myF_par2" select="%(column/name)"/>
		<admst:apply-templates select=".." match="utils_compare_nodes_position"/>
		<!-- if bigger check if 'smaller' exists -->
		<admst:if test="[$myF_ret1='bigger']">
			<admst:variable  name="local_ifelse" select="else"/>
			<admst:if test="(../jacobian[row/name=$myF_par2 and column/name=$myF_par1])">
				<admst:variable  name="local_ifelse" select="if"/>
			</admst:if>
			<admst:if test="[$local_ifelse='else']">
				<admst:variable  name="myF_ret1" select="smaller"/>				
				// COUNTER DOESNT EXIST
			</admst:if>
		</admst:if>
		<!-- TODO if there are only node1:node1 jacobian (without any other combinations),
		     it will not call iwant matrix
		-->
		<admst:if test="[$myF_ret1='smaller']">
			<!-- only if 1st node has smaller position than 2nd -->		
			<admst:text format="\n\tif( m_required[m_$(myF_par1)_$(myF_par2)]"/>
			<admst:text format=" || m_required[m_$(myF_par2)_$(myF_par1)]" 
				test="../jacobian[row/name=$myF_par2 and column/name=$myF_par1]"/>
			<admst:text format=" || m_required[m_$(myF_par1)_$(myF_par1)]"
				test="../jacobian[row/name=$myF_par1 and column/name=$myF_par1]"/>
			<admst:text format=" || m_required[m_$(myF_par2)_$(myF_par2)]"
				test="../jacobian[row/name=$myF_par2 and column/name=$myF_par2]"/>
			<admst:text format=" ) \n\t\ttr_call_iwants(_N($(myF_par1)).m_(), _N($(myF_par2)).m_());"/>
		</admst:if>
	</admst:for-each>
	//tr_iwant_matrix_extended();
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::ac_iwant_matrix()
{
	<admst:for-each select="jacobian">
		<admst:variable  name="myF_par1" select="%(row/name)"/>
		<admst:variable  name="myF_par2" select="%(column/name)"/>
		<admst:apply-templates select=".." match="utils_compare_nodes_position"/>
		<!-- if bigger check if 'smaller' exists -->
		<admst:if test="[$myF_ret1='bigger']">
			<admst:variable  name="local_ifelse" select="else"/>
			<admst:if test="(../jacobian[row/name=$myF_par2 and column/name=$myF_par1])"><admst:variable  name="local_ifelse" select="if"/></admst:if>
			<admst:if test="[$local_ifelse='else']">
				<admst:variable  name="myF_ret1" select="smaller"/>				
				// COUNTER DOESNT EXIST
			</admst:if>
		</admst:if>
		<!-- TODO if only equal exists (without any other combinations), it will not call iwant matrix -->
		<admst:if test="[$myF_ret1='smaller']">
			<!-- only if 1st node has smaller position than 2nd -->		
			<admst:text format="\n\tif( m_required[m_$(myF_par1)_$(myF_par2)]"/>
			<admst:text format=" || m_required[m_$(myF_par2)_$(myF_par1)]" test="../jacobian[row/name=$myF_par2 and column/name=$myF_par1]"/>
			<admst:text format=" || m_required[m_$(myF_par1)_$(myF_par1)]" test="../jacobian[row/name=$myF_par1 and column/name=$myF_par1]"/>
			<admst:text format=" || m_required[m_$(myF_par2)_$(myF_par2)]" test="../jacobian[row/name=$myF_par2 and column/name=$myF_par2]"/>
			<admst:text format=" ) \n\t\t_sim->_acx.iwant(_N($(myF_par1)).m_(), _N($(myF_par2)).m_());"/>
		</admst:if>
	</admst:for-each>
	//ac_iwant_matrix_extended();
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::tr_begin()
{
  const COMMON_COMPONENT* c = asserted_cast<const COMMON_COMPONENT*>(common());
  USE(c);

  const $(MODEL_NAME)* m = prechecked_cast<const $(MODEL_NAME)*>(model());
  assert(m);
  USE(m);

  trace0("$(DEV_NAME)::tr_begin");
  ADMS_BASE::tr_begin();

	// initial step

	<admst:apply-templates select="analog" match="analog:initial_step"/>
	// /initial step

        assert($_num_states == _num_states);
        for(int ii=0; ii<OPT::_keep_time_steps; ii++){
          trace1("$(DEV_NAME)::tr_begin", ii);
          std::fill_n(_states[ii], ($_num_states)*2, 0);
        }
		std::fill_n(_states_q1, ($_num_states), 0);

	// like d_vs.
	// <admst:text format="\n\tfor(int i=0; i<_num_total_nodes; i++)"/>
	for(int i=0; i<_num_total_nodes; i++)
		it0[i] = it1[i]=0;

        //     in storag:
        // _m1 = _m0 = CPOLY1(0., 0., 0.);
	std::fill_n(m_entries, %(count(jacobian)), 0);
	std::fill_n(m_entries_old, %(count(jacobian)), 0);

	internal_precalc();

	// load static ??
        //<admst:text format="\n\tfor(int i=0; i<_num_total_nodes; i++)"/>
        //	tr_load_source_point(_n[i], &(it0[i]), &(it1[i]));
        //

#ifdef load_in_begin

	<admst:for-each select="jacobian[static='yes']">
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	if( m_required[m_%s_%s] )
  		tr_load_point(_N(%s), _N(%s), &(m_entries[m_%s_%s]), &(m_entries_old[m_%s_%s]));
              </admst:for-each>
#endif

        q_load();

}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::dc_advance(){
	trace0("$(DEV_NAME)::dc_advance");

	// ELEMENT:: does nothing

	ADMS_BASE::dc_advance(); 

#if ($_num_states)
	for (int t = 1;  t < OPT::_keep_time_steps;  ++t) {
		//  notstd::copy_n(_states[0], 2*(unsigned)_num_states, _states[i]);
		//_i[t] = _i[0]; <= what STORAGE does

		for( unsigned i=0; i<_num_states; ++i){
			_states[t][2*i+1]=_states[0][2*i+1];
		}

	}
#endif
	// ??
	//		for( unsigned i=0; i<_num_states; ++i){
	//			_states_1[2*i+1]=_states[0][2*i+1];
	//		}
	//

}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::tr_advance()
{
  trace0("$(DEV_NAME)::tr_advance");
  ADMS_BASE::tr_advance();

  // FIXME:
  // <if(have states)>
  //   ADMS_BASE::tr_advance_states()
  // </if>

  // shift states, clear states[0]
  double* t = _states[OPT::_keep_time_steps-1];
  for (int ii = OPT::_keep_time_steps-1;  ii > 0;  --ii){
    _states[ii] = _states[ii-1];
  }
  _states[0] = t;

  //initial guess.
  notstd::copy_n(_states[1], 2*(unsigned) _num_states, _states[0]);


// storage would do:
//for (int i=OPT::_keep_time_steps-1; i>0; --i) {
//_i[i] = _i[i-1];
// }
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::tr_regress()
{
  ADMS_BASE::tr_regress();
}
// -------------------------------------------------------------------------- //
bool $(DEV_NAME)::tr_needs_eval()const
{
  trace3("$(DEV_NAME)::tr_needs_eval", converged(), is_q_for_eval(), _sim->is_advance_iteration());
  if (is_q_for_eval()) return false;
  if (!converged()) return true;
  if (_sim->is_advance_iteration()) return true;
  if (_time[1] == 0){
    trace0("tr_needs_eval: //BUG// needed?? for ngspice jfet, but not for spice3f5 jfet");
    return true;
  }

  // check the node voltages, reference to ground
  for (unsigned ii=0; ii<matrix_nodes(); ++ii) 
    // probably simpler: if (!conchk(_sim->_n[ii].vt1(), _n[ii].v0(), 0, OPT::reltol*OPT::bypasstol)) 
    if (!conchk(_sim->_vt1[_n[ii].m_()], _n[ii].v0(), 0, OPT::reltol*OPT::bypasstol)) {
      trace1("$(DEV_NAME)::tr_needs_eval node", ii);
      return true;
    }

  // check the node voltages, reference to each other
  for (unsigned ii=0; ii<matrix_nodes(); ++ii){
    for (unsigned jj=0; jj<ii; ++jj) {
      // node_t has no vt1... if (!conchk( ( _n[ii].vt1()  - _n[jj].vt1() ),
      // assert(  _n[ii].vt1() = _sim->_vt1[_n[ii].m_()] );
      if (!conchk((_sim->_vt1[_n[ii].m_()] - _sim->_vt1[_n[jj].m_()]),
        (_n[ii].v0() - _n[jj].v0()), 0, OPT::reltol*OPT::bypasstol)) {

         trace2("$(DEV_NAME)::tr_needs_eval", ii, jj);
        
        return true;
      }
    }
  }

  trace0("$(DEV_NAME)::tr_needs_eval: no");

  return false;
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::tr_eval_kept()
{
#if 0
<!-- <admst:apply-templates select="analog/code[datatypename='block']/item" match="tr_eval_kept" required="yes"/> -->
#endif
}
// -------------------------------------------------------------------------- //
// MODEINITFLOAT = normal iteration
// MODEINITPRED  = 1st iter at a new time point
// MODEINITTRAN  = 1st iter at 1st time pt after initial DC
// MODEINITFIX   = like FLOAT, but honor options like "off"
// MODEINITJCT   = initial guess
// MODEINITSMSIG = like FLOAT, but setup for small signal, don't load arrays
// -------------------------------------------------------------------------- //
bool $(DEV_NAME)::do_tr()
{
	trace1("$(DEV_NAME)::do_tr", long_label());
	assert(OPT::_keep_time_steps <= 8);  
	assert(_dt == NOT_VALID || conchk(_dt, _time[0] - _time[1]));

	int mode;
	if (_sim->analysis_is_tran_dynamic()) 
	{
          trace1("$(DEV_NAME)::do_tr tran dynamic", long_label());
          if ((_time[1] == 0) && _sim->is_first_iteration()) mode = MODETRAN | MODEINITTRAN;
          else mode = MODETRAN | MODEINITFLOAT;

          tr_eval(); // if needed??
          q_load(); 

        } else if(_sim->more_uic_now() && is_constant() ) {
          assert(_time[0] == 0.);

          tr_eval_kept();

        } else {
		if (_sim->analysis_is_tran_static()) 		mode = MODETRANOP;		
		else if (_sim->analysis_is_tran_restore()) 	mode = MODETRAN;
		else if (_sim->command_is_dc()) 			mode = MODEDCTRANCURVE;
		else if (_sim->command_is_op()) 			mode = MODEDCOP;
		else {unreachable();mode = 0;}
		
		if (_sim->uic_now()) 
		{
			mode |= MODEINITFIX;
			mode |= MODEUIC;
		}
		else 
			if (_sim->is_initial_step()) mode |= MODEINITJCT;
                        else mode |= MODEINITFLOAT;


          tr_eval(); // if needed??
          q_load(); 
	}
  
	// convergence check -- gnucap method
	set_converged(true);

// FIXME: dont use cpp.
#if ($_num_states)
	for (unsigned ii = 0; ii < _num_states; ++ii) 	// analog to e_cap.cc do_tr();
	{
		set_converged(converged() && conchk(_states[0][ii*2], _states_q1[ii]));	// was _states_1 originally
//		trace3("", ii, _states_1[ii], _states[0][ii]);
//		_states_1[ii] = _states[0][ii];
                }	
#endif
	
	for(int i=0; converged() && i<_num_total_nodes; i++)
	{
		assert(is_number(it0[i]));	
		bool conv= conchk(it0[i], it1[i]);	
		if (!conv) {
			trace6("tr_eval: i not converged ", i , it0[i], it1[i], _sim->iteration_number(), it0[i]-it1[i], conv );
			set_converged(false);	
		}
	}
	
	
	<admst:text format="\n\tfor(int i=0; converged() && i<%(count(jacobian)); i++)"/>
        if (m_entries[i]){
		bool conv = conchk(m_entries[i], m_entries_old[i]);
		if (!conv) {
			trace4("tr_eval: m not converged", i , m_entries[i], m_entries_old[i], _sim->iteration_number() );
			set_converged(conv);
		}
	}

	bool needs_load = !converged();
	for (int i = 0; !needs_load && i < _num_total_nodes; i++) {
		if (m_required[i]){
			needs_load = !conchk(it0[i], it1[i], 0, OPT::reltol*OPT::loadtol);
		}
	}
			
  for(int i=0; !needs_load && i<%(count(jacobian)); i++)
    if (m_required[i]){
      needs_load = !conchk(m_entries[i], m_entries_old[i], 0, OPT::reltol * OPT::loadtol);
    }
	
  store_values();

                // if (needs_load)
  trace2("$(DEV_NAME)::do_tr done ", converged(), needs_load );
  return converged();
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::keep_ic()
{
  //double x =  dn_diff(_n[OUT1].v0(),_n[OUT2].v0() ); // == tr_involts() ??
  const COMMON_COMPONENT* c = asserted_cast<const COMMON_COMPONENT*>(common());
  USE(c);
  const $(MODEL_NAME)* m = asserted_cast<const $(MODEL_NAME)*>(model());
  USE(m);

  trace1("$(DEV_NAME)::keep_ic", long_label() );

  <!-- 

  <admst:apply-templates select="analog/code" match="analog:evaluate" required="yes"/>

        -->

  // notstd::copy_n(m_entries, %(count(jacobian)) , m_entries_kept);
  // notstd::copy_n(_states_1 , %(count(jacobian)) , _states_kept); // FIXME
  notstd::copy_n(it0, (int)_num_total_nodes , i_kept);

}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::store_values() 
{
  trace1("$(DEV_NAME)::store_values", long_label());


  // notstd::copy_n(_states[0],(unsigned) 2*_num_states, _states_1);

#if ($_num_states)

  for( unsigned i=0; i<_num_states; ++i){
        _states_q1[i]=_states[0][2*i];
		  }
#endif

  // ELEMENT does y[0] -> y_1
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::tr_load()
{
  trace0("$(DEV_NAME)::tr_load");
          /// BUG: only dynamic!
  for(int i=0; i<_num_total_nodes; i++){
  trace3("tr_load", "i",     (it0[i]),  (it1[i]));
    tr_load_source_point(_n[i], &(it0[i]), &(it1[i]));

		trace3("tr_load done", "i",     (it0[i]),  (it1[i]));
	}
  
          /// BUG: only load dynamic nodes! ?

  <admst:for-each select="jacobian">
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
    if( m_required[m_%s_%s] ){
      trace4("tr_load", "%s", "%s", m_entries[m_%s_%s], m_entries_old[m_%s_%s]);
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
      tr_load_point(_N(%s), _N(%s), &(m_entries[m_%s_%s]), &(m_entries_old[m_%s_%s]));
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
      trace4("tr_load done ", "%s", "%s", m_entries[m_%s_%s], m_entries_old[m_%s_%s]);

    }
  </admst:for-each>
  
  <admst:for-each select="jacobian">
	  <admst:value-of select="column/name"/>
	  <admst:value-of select="row/name"/>
	  <admst:value-of select="column/name"/>
	  <admst:value-of select="row/name"/>
	  <admst:value-of select="column/name"/>
	  <admst:value-of select="row/name"/>
		if( !m_required[m_%s_%s] && (m_entries[m_%s_%s]!=0) ) printf("*** m_%s_%s\n");
  
  </admst:for-each>
  
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::tr_unload()
{
	untested();
	incomplete();
	_sim->mark_inc_mode_bad();
	tr_load();
}
// -------------------------------------------------------------------------- //
TIME_PAIR $(DEV_NAME)::tr_review()
{
	trace0("$(DEV_NAME)::tr_review");
	assert(_dt == NOT_VALID || conchk(_dt, _time[0] - _time[1]));

	double timestep = NEVER;
    //----- (DEVtrunc)
	<admst:for-each select="source[dynamic='yes']">
	<admst:value-of select="branch/nnode/name"/>
	<admst:value-of select="branch/pnode/name"/>
	CKTterr($(DEV_NAME)::state_%s_%s, &timestep);
	</admst:for-each>
    //-----

    _time_by._error_estimate = tr_review_check_and_convert(timestep);
    _time_by._event = NEVER;
    return _time_by;  
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::tr_accept()
{
  trace0("$(DEV_NAME)::tr_accept");
  if (_sim->analysis_is_dcop() || _sim->analysis_is_ac()) {
    assert(_dt == NOT_VALID || conchk(_dt, _time[0] - _time[1]));
    int mode;
    mode = MODEINITSMSIG;
    // huh??    load(mode);
  } else { itested(); }
}
// -------------------------------------------------------------------------- //
double $(DEV_NAME)::tr_probe_num(const std::string& x)const
{
	static std::string state_names[_num_states];
	static std::string node_names_n[_num_total_nodes];

	// init states & node names	
	for(int i=0; i<_num_states; i++)
	{
		std::stringstream ss;
		ss << i;
		state_names[i] = "state" + ss.str();
	}
	for(int i=0; i<_num_total_nodes; i++)
	{
		std::stringstream ss;
		ss << i;
		node_names_n[i] = "cont" + ss.str();
	}

	assert(_dt == NOT_VALID || conchk(_dt, _time[0] - _time[1]));

	if (Umatch(x, "conv{erged} "))
	    return converged();

	// states probes
	for (int ii=0; ii<_num_states; ++ii) 
		if (Umatch(x, state_names[ii] + ' ')) 
			return _states[0][ii];
	// node probes
	for(int i=0; i<_num_total_nodes; i++)
		if( Umatch(x, node_names_n[i] + ' ') )
			return it0[i];
	
	// verilog-variables ('global_instance' eq. with 'ask' field)
	<admst:for-each select="variable[input='no' and scope='global_instance']">
	if( Umatch(x, "%(.) ") )
		return $(var_prefix)%(.);

	</admst:for-each>

  return ADMS_BASE::tr_probe_num(x);
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::ac_begin()
{
  ADMS_BASE::ac_begin();
  internal_precalc();
  tr_accept();
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::do_ac()
{
  assert(OPT::_keep_time_steps <= 8);  
  assert(_dt == NOT_VALID || conchk(_dt, _time[0] - _time[1]));
    
  std::fill_n(it0, (int)_num_total_nodes, 0);
  std::fill_n(it1, (int)_num_total_nodes, 0);
    
  std::fill_n(m_entries, %(count(jacobian)), 0);
  std::fill_n(m_entries_old, %(count(jacobian)), 0);
    
  //pzLoad(_sim->_jomega);

  ac_eval();

  #if 0
  <admst:apply-templates select="analog/code[datatypename='block']" match="ac_load" required="yes"/>
  #endif
}
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::ac_load()
{
	for(int i=0; i<_num_total_nodes; i++)
	ac_load_source_point(_n[i], COMPLEX(it0[i], it1[i]));
		
	<admst:for-each select="jacobian">
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	if( m_required[m_%s_%s] ) ac_load_point(_N(%s), _N(%s), COMPLEX(m_entries[m_%s_%s], m_entries_old[m_%s_%s]));
	</admst:for-each>
}

// -------------------------------------------------------------------------- //
void $(DEV_NAME)::CKTterr(int qcap, double *time_step)
{
	std::valarray<FPOLY1> q(OPT::_keep_time_steps);

	for (int ii = 0; ii < OPT::_keep_time_steps; ++ii) 
	{
		assert(_states[ii]);
		q[ii].x  = NOT_VALID;      	
		q[ii].f0 = _states[ii][qcap];
		q[ii].f1 = NOT_VALID;
	}

	*time_step = std::min(tr_review_trunc_error(&q[0]), *time_step);
}

// -------------------------------------------------------------------------- //
void $(DEV_NAME)::guesstopology ()
{
	for(int i=0; i<%(count(jacobian)); i++)
        	m_required[i] = false;
	
	#include "$(filename)_guesstopology.hxx"
 
 	for(int i=0; i<%(count(jacobian)); i++) trace1("guess m", m_required[i]);
}	

// -------------------------------------------------------------------------- //
#if 0
void $(DEV_NAME)::acLoad()
{ 
<admst:for-each select="jacobian[static='yes']">
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:text format="\n\tif(m_required[m_%s_%s]) m_entries[m_%s_%s] += m_ac_static[m_%s_%s]; // static"/>
</admst:for-each>

<admst:text format="\n"/>
<admst:for-each select="jacobian[dynamic='yes']">
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:text format="\n\tif(m_required[m_%s_%s]) m_entries_old[m_%s_%s] += _sim->_jomega.imag() * m_ac_dynamic[m_%s_%s]; // dynamic"/>
</admst:for-each>
}
	
// -------------------------------------------------------------------------- //
void $(DEV_NAME)::pzLoad(COMPLEX s)
{
<admst:for-each select="jacobian[static='yes']">
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:text format="\n\tif(m_required[m_%s_%s]) m_entries[m_%s_%s] += m_ac_static[m_%s_%s] * s.real(); // static"/>
</admst:for-each>
	
<!-- why two selects?? -->
<admst:text format="\n"/>
<admst:for-each select="jacobian[dynamic='yes']">
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:text format="\n\tif(m_required[m_%s_%s]) m_entries[m_%s_%s] += m_ac_dynamic[m_%s_%s] * s.real(); //dynamic"/>
</admst:for-each>

<admst:text format="\n"/>
<admst:for-each select="jacobian[dynamic='yes']">
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:value-of select="column/name"/>
	<admst:value-of select="row/name"/>
	<admst:text format="\n\tif(m_required[m_%s_%s]) m_entries_old[m_%s_%s] += m_ac_dynamic[m_%s_%s] * s.imag(); //dynamic"/>
</admst:for-each>
}
#endif

// -------------------------------------------------------------------------- //
bool $(DEV_NAME)::conv_check()const
{
<admst:if test="[($_num_states!='0')]">
	//nst
</admst:if>
#if ($_num_states)
// FIXME
  for (unsigned ii = 0; ii < _num_states; ++ii) 
  {
    if (! conchk(_states[0][2*ii], _states_q1[ii]))
      return false;
      }	
#endif

  <admst:text format="\n\tfor(unsigned i=0; converged() && i<_num_total_nodes; i++)"/>
  { 
    bool conv = conchk(it0[i], it1[i]);	
    if (!conv) {
        return false;
    }
  }

  for(unsigned i=0; converged() && i<%(count(jacobian)); i++)
  {
    bool conv = conchk(m_entries[i], m_entries_old[i]);
    if (!conv) { trace4("conv check: not converged", i , m_entries[i], m_entries_old[i], _sim->iteration_number() );}
        return false;
  }
  return true;

}

// -------------------------------------------------------------------------- //
// write G and C into
// matrix and matrix_old
void $(DEV_NAME)::ac_eval() 
{
<!--
	std::fill_n(it0, (int)_num_total_nodes, 0);
	std::fill_n(m_entries, %(count(jacobian)), 0);

	const COMMON_COMPONENT* c = asserted_cast<const COMMON_COMPONENT*>(common());
	USE(c);
	const $(MODEL_NAME)* m = asserted_cast<const $(MODEL_NAME)*>(model());
	USE(m);
	double CKTag0=0;


	<admst:text format="\n\tstd::fill_n(m_entries, %(count(jacobian)), 0);"/>
	<admst:text format="\n\tstd::fill_n(m_entries_old, %(count(jacobian)), 0);"/>
									
	{ // analog:eval

	 <admst:variable name="eval_mode" select="ac"/>
	 current_state=0; // FIXME
	 <admst:apply-templates select="analog/code" match="analog:evaluate" required="yes"/>


	} // analog:eval
-->
	return; 
}
// -------------------------------------------------------------------------- //

void $(DEV_NAME)::tr_eval() 
{
	std::fill_n(it0, (int)_num_total_nodes, 0);
	std::fill_n(m_entries, %(count(jacobian)), 0);

	<admst:apply-templates select="analog/code[datatypename='block']/variable" match="generate_c:declare_variable"/>

	const COMMON_COMPONENT* c = asserted_cast<const COMMON_COMPONENT*>(common());
	USE(c);
	const $(MODEL_NAME)* m = asserted_cast<const $(MODEL_NAME)*>(model());
	USE(m);

	double CKTag0;
	assert( _dt != 0 ); // untested, tag0 = 0.0
	if (_time[1] != 0 && _method_a == mTRAP) CKTag0 = 2 / _dt; // mTRAP
	else CKTag0 = 1 / _dt; // mEULER

	trace2("$(DEV_NAME)::tr_eval()", long_label(), CKTag0);

	{
		current_state=0;
		<admst:variable name="eval_mode" select="tr"/>
		current_state=0; // FIXME
	
		#include "$(filename)_tr_eval.hxx"
	}

	// this is what cap does.
	set_converged(conv_check());
	return; 
}

  </admst:for-each>
</admst:open>

<!-- *********************************************************************************** -->
<!-- *********************************** constant text ********************************* -->
<!-- *********************************************************************************** -->

<!-- ----------------------------------------------------------------- -->
<admst:template match="c:myfunc:math_h">
<admst:message test="[/dbg_xml='yes']" format="*c:myfunc:math_h*\n"/>
inline double doh(double x)            {return  log(1+exp(x)); }
inline double d_doh(double x)          {return  exp(x)/(exp(x) + 1); }
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="Printhxxdefines">
<admst:message test="[/dbg_xml='yes']" format="*Printhxxdefines*\n"/>
//  *** ngspice \$simparam variables ***
//	gdev                (1/Ohms): Additional conductance to be added to nonlinear branches for conductance homotopy convergence algorithm.
//	gmin                (1/Ohms): Minimum conductance placed in parallel with nonlinear branches.
//	imax                (Amps)  : Branch current threshold above which the constitutive relation of a nonlinear branch should be linearized.
//	imelt               (Amps)  : Branch current threshold indicating device failure.
//	iteration                   : Iteration number of the analog solver.
//	scale                       : Scale factor for device instance geometry parameters.
//	shrink                      : Optical linear shrink factor.
//	simulatorSubversion         : The simulator sub-version.
//	simulatorVersion            : The simulator version.
//	sourceScaleFactor           : Multiplicative factor for independent sources for source stepping homotopy convergence algorithm.
//	tnom degrees       (Celsius): Default value of temperature at which model parameters were extracted.

#define _cos(val,arg)            val = cos(arg);
#define _d_cos(val,dval,arg)     val = cos(arg);     dval = (-sin(arg));
#define _sin(val,arg)            val = sin(arg);
#define _d_sin(val,dval,arg)     val = sin(arg);     dval = (cos(arg));
#define _tan(val,arg)            val = tan(arg);
#define _d_tan(val,dval,arg)     val = tan(arg);     dval = (1.0/cos(arg)/cos(arg));
#define _hypot(xy,x,y)           xy = sqrt((x)*(x)+(y)*(y));
#define _dx_hypot(dx,xy,x,y)     dx = (x)/(xy);
#define _dy_hypot(dy,xy,x,y)     dy = (y)/(xy);
#define _max(xy,x,y)             xy = ((x)>(y))?(x):(y);
#define _dx_max(dx,xy,x,y)       dx = ((x)>(y))?1.0:0.0;
#define _dy_max(dy,xy,x,y)       dy = ((x)>(y))?0.0:1.0;
#define _min(xy,x,y)             xy = ((x)<(y))?(x):(y);
#define _dx_min(dx,xy,x,y)       dx = ((x)<(y))?1.0:0.0;
#define _dy_min(dy,xy,x,y)       dy = ((x)<(y))?0.0:1.0;
#define _cosh(val,arg)           val = cosh(arg);
#define _d_cosh(val,dval,arg)    val = cosh(arg);    dval = (sinh(arg));
#define _sinh(val,arg)           val = sinh(arg);
#define _d_sinh(val,dval,arg)    val = sinh(arg);    dval = (cosh(arg));
#define _tanh(val,arg)           val = tanh(arg);
#define _d_tanh(val,dval,arg)    val = tanh(arg);    dval = (1.0/cosh(arg)/cosh(arg));
#define _acos(val,arg)           val = acos(arg);
#define _d_acos(val,dval,arg)    val = acos(arg);    dval = (-1.0/sqrt(1-arg*arg));
#define _asin(val,arg)           val = asin(arg);
#define _d_asin(val,dval,arg)    val = asin(arg);    dval = (+1.0/sqrt(1-arg*arg));
#define _atan(val,arg)           val = atan(arg);
#define _d_atan(val,dval,arg)    val = atan(arg);    dval = (+1.0/(1+arg*arg));
#define _logE(val,arg)           val = log(arg);
#define _d_logE(val,dval,arg)    val = log(arg);     dval = (1.0/arg);
#define _log10(val,arg)          val = log10(arg);
#define _d_log10(val,dval,arg)   val = log10(arg);   dval = (1.0/arg/log(10));
#define _exp(val,arg)            val = exp(arg);
#define _d_exp(val,dval,arg)     val = exp(arg);     dval = val;
#define _sqrt(val,arg)           val = sqrt(arg);
#define _d_sqrt(val,dval,arg)    val = sqrt(arg);    dval = (1.0/val/2.0);
#define _pow(xy,x,y)             xy = pow(x,y);
#define _dx_pow(dx,xy,x,y)       dx = (x==0.0)?0.0:((y/x)*xy);
#define _dy_pow(dy,xy,x,y)       dy = (x==0.0)?0.0:((log(x)/exp(0.0))*xy);

#define _div1(x,y)               ((x)/(y))
#define _div0(xy,x,y)            xy=(x)/(y);
#define _div(xy,dx,x,y)          dx=1/(y); xy=(x)*dx;
#define _dx_div(dx,xy,x,y)
#define _dy_div(dy,dx,xy,x,y)    dy = -xy*dx;

#define _limexp(val,arg)         val = ((arg)&lt;<(90)) ? (exp(arg)) : (exp(90)*(1.0+(arg-90)));
#define _d_limexp(val,dval,arg)  val = ((arg)&lt;(90)) ? (exp(arg)) : (exp(90)*(1.0+(arg-90))); dval = val;
#define _fabs(val,arg)           val = fabs(arg);
#define _d_fabs(val,dval,arg)    val = fabs(arg);    dval = (((val)>=0)?(+1.0):(-1.0));
#define _abs(val)                ((val)<(0) ? (-(val)):(val))

</admst:template>

<admst:template match="PrintHxxFunctions">
inline double _cos(double arg)             { return  cos(arg); }
inline double _d0_cos(double arg)          { return (-sin(arg)); }
inline double _sin(double arg)             { return  sin(arg); }
inline double _d0_sin(double arg)          { return (cos(arg)); }
inline double _tan(double arg)             { return  tan(arg); }
inline double _d0_tan(double arg)          { return (1.0/cos(arg)/cos(arg)); }
inline double _cosh(double arg)            { return  cosh(arg); }
inline double _d0_cosh(double arg)         { return (sinh(arg)); }
inline double _sinh(double arg)            { return  sinh(arg); }
inline double _d0_sinh(double arg)         { return (cosh(arg)); }
inline double _tanh(double arg)            { return  tanh(arg); }
inline double _d0_tanh(double arg)         { return (1.0/cosh(arg)/cosh(arg)); }
inline double _acos(double arg)            { return  acos(arg); }
inline double _d0_acos(double arg)         { return (-1.0/sqrt(1-arg*arg)); }
inline double _asin(double arg)            { return  asin(arg); }
inline double _d0_asin(double arg)         { return (+1.0/sqrt(1-arg*arg)); }
inline double _atan(double arg)            { return  atan(arg); }
inline double _d0_atan(double arg)         { return (+1.0/(1+arg*arg)); }
inline double _logE(double arg)            { return  log(arg); }
inline double _d0_logE(double arg)         { return (1.0/arg); }
inline double _log10(double arg)           { return  log10(arg); }
inline double _d0_log10(double arg)        { return (1.0/arg/log(10)); }
inline double _exp(double arg)             { return  exp(arg); }
inline double _d0_exp(double arg)          { return exp(arg); } /* fixme */
inline double _sqrt(double arg)            { return  sqrt(arg); }
inline double _d0_sqrt(double arg)         { return (1.0/sqrt(arg)/2.0); } /* fixme */
inline double _abs(double arg)             { return  fabs(arg); }
inline double _d0_abs(double arg)          { return (((arg)>=0)?(+1.0):(-1.0)); }

inline double _hypot(double x,double y)    { return sqrt((x)*(x)+(y)*(y)); }
inline double _d0_hypot(double x,double y) { return (x)/sqrt((x)*(x)+(y)*(y)); } /* fixme */
inline double _d1_hypot(double x,double y) { return (y)/sqrt((x)*(x)+(y)*(y)); } /* fixme */

inline double _max(double x,double y)      { return ((x)>(y))?(x):(y); }
inline double _d0_max(double x,double y)   { return ((x)>(y))?1.0:0.0; }
inline double _d1_max(double x,double y)   { return ((x)>(y))?0.0:1.0; }

inline double _min(double x,double y)      { return ((x)<(y))?(x):(y); }
inline double _d0_min(double x,double y)   { return ((x)<(y))?1.0:0.0; }
inline double _d1_min(double x,double y)   { return ((x)<(y))?0.0:1.0; }

inline double _pow(double x,double y)      { return pow(x,y); }
inline double _d0_pow(double x,double y)   { return (x==0.0)?0.0:((y/x)*pow(x,y)); } /* fixme */
inline double _d1_pow(double x,double y)   { return (x==0.0)?0.0:((log(x)/exp(0.0))*pow(x,y)); } /* fixme */

inline double _limexp(double arg)  { return  ((arg)<(90)) ? (exp(arg)) : (exp(90)*(1.0+(arg-90))); }
inline double _d0_limexp(double arg) { return  ((arg)<(90)) ? (exp(arg)) : (exp(90)*(1.0+(arg-90))); }

<!--inline double $(module)_vt (double Tdev) {
  return 1.3806503e-23*Tdev/1.602176462e-19;
}
inline double $(module)_d_vt (double Tdev, double d_Tdev) {
  double vt_Tdev=1.3806503e-23/1.602176462e-19;
  return vt_Tdev*d_Tdev;
}
< -->

</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="Printhxxwrapperdefines">
<admst:message test="[/dbg_xml='yes']" format="*Printhxxwrapperdefines*\n"/>
// ******************** load definitions ***************************
#define _eval_static_residual1(p,v)\
	it0[p ## Node]-=v;
#define _keep_static_residual2(p,n,v)\
	kept[p ## Node]-=v;\
        kept[n ## Node]+=v;		

        <!-- still in use -->
#define _eval_static_residual2(p,n,v)\
	it0[$node_prefix ##p ]-=v;\
	it0[$node_prefix ##n]+=v;		

	
</admst:template>

<!-- *********************************************************************************** -->
<!--******************************** tree traverse - datatypename ********************** -->
<!-- *********************************************************************************** -->

<!-- ----------------------------------------------------------------- -->
<admst:template match="stringify_expression">
<admst:message test="[/dbg_xml='yes']" format="*stringify_expression*\n"/>
  <!-- expression:stringify:noprobe =====> select="blablabla/tree" match="stringify_expression" -->
  <!-- subexpression:stringify:noprobe =====> select="blablabla" match="stringify_expression"   -->
  <admst:apply-templates select="." match="%(./adms/datatypename)"/>
  <admst:value-of select="/simulator/tmp"/>
</admst:template>

<!-- analog//callfunctions -->
<admst:template match="callfunction">
  <admst:choose>
    <admst:when test="function[name='\$strobe']">
      <admst:text format="_strobe("/>
    </admst:when>
    <admst:when test="function[name='\$warning']">
      <admst:text format="_warning("/>
    </admst:when>
    <admst:when test="function[name='\$error']">
      <admst:text format="_error("/>
    </admst:when>
    <admst:when test="function[name='\$finish']">
      <admst:text format="_finish("/>
    </admst:when>
    <admst:when test="function[name='\$stop']">
      <admst:text format="_stop("/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="/simulator/tmp"/>
      <admst:value-of select="function/name"/>
      <admst:error format="function not supported: %s(%s)\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:reset select="/simulator/tmp"/>
  <admst:join select="function/arguments" separator=",">
    <admst:apply-templates select="./tree" match="stringify_expression"/>%s</admst:join>
  <admst:text format=");\n"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="mapply_unary">
<admst:message test="[/dbg_xml='yes']" format="*mapply_unary*\n"/>
  <admst:choose>
    <admst:when test="[name='plus']">
      <admst:choose>
        <admst:when test="arg1/math[value=0.0]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="stringify_expression"/>
          <admst:value-to select="/simulator/tmp" value="(+%s)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='minus']">
      <admst:choose>
        <admst:when test="arg1/math[value=0.0]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="stringify_expression"/>
          <admst:value-to select="/simulator/tmp" value="(-%s)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='not']">
      <admst:choose>
        <admst:when test="arg1/math[value=0.0]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="stringify_expression"/>
          <admst:value-to select="/simulator/tmp" value="(!%s)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='bw_not']">
      <admst:choose>
        <admst:when test="arg1/math[value=0.0]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="stringify_expression"/>
          <admst:value-to select="/simulator/tmp" value="(~%s)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="name"/>
      <admst:error format="%s: function not handled\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="/simulator/probe">
    <admst:choose>
      <admst:when test="/simulator[tmp='0.0']">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:when>
      <admst:otherwise>
        <admst:choose>
          <admst:when test="[name='plus']">
            <admst:choose>
              <admst:when test="/simulator[ddx!='0.0']">
                <admst:value-of select="/simulator/ddx"/>
                <admst:value-to select="/simulator/ddx" value="(+%s)"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='minus']">
            <admst:choose>
              <admst:when test="/simulator[ddx!='0.0']">
                <admst:value-of select="/simulator/ddx"/>
                <admst:value-to select="/simulator/ddx" value="(-%s)"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='not']">
            <admst:choose>
              <admst:when test="/simulator[ddx!='0.0']">
                <admst:value-of select="/simulator/ddx"/>
                <admst:value-to select="/simulator/ddx" value="(!%s)"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='bw_not']">
            <admst:choose>
              <admst:when test="/simulator[ddx!='0.0']">
                <admst:value-of select="/simulator/ddx"/>
                <admst:value-to select="/simulator/ddx" value="(~%s)"/>
              </admst:when>
            </admst:choose>
          </admst:when>
        </admst:choose>
      </admst:otherwise>
    </admst:choose>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="mapply_binary">
<admst:message test="[/dbg_xml='yes']" format="*mapply_binary*\n"/>
  <admst:choose>
    <admst:when test="[name='bw_equr']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s^~%s)"/>
    </admst:when>
    <admst:when test="[name='bw_equl']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s~^%s)"/>
    </admst:when>
    <admst:when test="[name='bw_xor']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s^%s)"/>
    </admst:when>
    <admst:when test="[name='bw_or']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s|%s)"/>
    </admst:when>
    <admst:when test="[name='bw_and']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s&amp;%s)"/>
    </admst:when>
    <admst:when test="[name='multmod']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s%%%s)"/>
    </admst:when>
    <admst:when test="[name='or']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s||%s)"/>
    </admst:when>
    <admst:when test="[name='and']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s&amp;&amp;%s)"/>
    </admst:when>
    <admst:when test="[name='equ']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s==%s)"/>
    </admst:when>
    <admst:when test="[name='notequ']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s!=%s)"/>
    </admst:when>
    <admst:when test="[name='lt']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s&lt;%s)"/>
    </admst:when>
    <admst:when test="[name='lt_equ']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s&lt;=%s)"/>
    </admst:when>
    <admst:when test="[name='gt']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s&gt;%s)"/>
    </admst:when>
    <admst:when test="[name='gt_equ']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s&gt;=%s)"/>
    </admst:when>
    <admst:when test="[name='shiftr']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s&gt;&gt;%s)"/>
    </admst:when>
    <admst:when test="[name='shiftl']">
      <admst:apply-templates select="arg2" match="stringify_expression"/>
      <admst:apply-templates select="arg1" match="stringify_expression"/>
      <admst:value-to select="/simulator/tmp" value="(%s&lt;&lt;%s)"/>
    </admst:when>
    <admst:when test="[name='addp']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="arg1/math[value=0.0]">
          <admst:apply-templates select="arg2" match="stringify_expression"/>
          <admst:value-to select="/simulator/tmp" value="(+%s)"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
            <admst:variable name="dx" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="arg2/math[value=0.0]">
          <admst:apply-templates select="arg1" match="stringify_expression"/>
          <admst:value-to select="/simulator/tmp" value="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="stringify_expression"/>
          <admst:variable name="x" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
          </admst:if>
          <admst:apply-templates select="arg2" match="stringify_expression"/>
          <admst:variable name="y" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
          </admst:if>
          <admst:value-to select="/simulator/tmp" value="($x+$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='addm']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="arg1/math[value=0.0]">
          <admst:apply-templates select="arg2" match="stringify_expression"/>
          <admst:value-to select="/simulator/tmp" value="(-%s)"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
            <admst:variable name="dx" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="arg2/math[value=0.0]">
          <admst:apply-templates select="arg1" match="stringify_expression"/>
          <admst:value-to select="/simulator/tmp" value="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="stringify_expression"/>
          <admst:variable name="x" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
          </admst:if>
          <admst:apply-templates select="arg2" match="stringify_expression"/>
          <admst:variable name="y" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
          </admst:if>
          <admst:value-to select="/simulator/tmp" value="($x-$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multtime']">
      <admst:variable name="x" select="0.0"/>
      <admst:variable name="y" select="0.0"/>
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)or(arg2/math/value=0.0)]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:value-to select="/simulator/tmp" value="1.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="stringify_expression"/>
          <admst:variable name="x" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
          </admst:if>
          <admst:apply-templates select="arg2" match="stringify_expression"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
          </admst:if>
          <admst:variable name="y" select="%s"/>
          <admst:value-to select="/simulator/tmp" value="($x*$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multdiv']">
      <admst:variable name="x" select="0.0"/>
      <admst:variable name="y" select="0.0"/>
      <admst:choose>
        <admst:when test="arg1/math[value=0.0]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:value-to select="/simulator/tmp" value="1.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="stringify_expression"/>
          <admst:variable name="x" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
          </admst:if>
          <admst:apply-templates select="arg2" match="stringify_expression"/>
          <admst:variable name="y" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
          </admst:if>
          <admst:value-to select="/simulator/tmp" value="($x/$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="name"/>
      <admst:error format="%s: function not handled\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:if test="/simulator/probe">
    <admst:choose>
      <admst:when test="[name='addp']">
        <admst:choose>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:value-to select="/simulator/ddx" value="(+$dy)"/>
          </admst:when>
          <admst:when test="[$dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="$dx"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="/simulator/ddx" value="($dx+$dy)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='addm']">
        <admst:choose>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:value-to select="/simulator/ddx" value="(-$dy)"/>
          </admst:when>
          <admst:when test="[$dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="$dx"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="/simulator/ddx" value="($dx-$dy)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:choose>
          <admst:when test="[$x='0.0' and $y='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0' and $dy='1.0']">
            <admst:value-to select="/simulator/ddx" value="($x)"/>
          </admst:when>
          <admst:when test="[$dx='1.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="($y)"/>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:value-to select="/simulator/ddx" value="($x*$dy)"/>
          </admst:when>
          <admst:when test="[$dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="$dx*$y"/>
          </admst:when>
          <admst:when test="[$dx='1.0' and $dy='1.0']">
            <admst:value-to select="/simulator/ddx" value="($x+$y)"/>
          </admst:when>
          <admst:when test="[$dx='1.0']">
            <admst:value-to select="/simulator/ddx" value="($y+($dy*$x))"/>
          </admst:when>
          <admst:when test="[$dy='1.0']">
            <admst:value-to select="/simulator/ddx" value="($dx*$y)+$x"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:value-to select="/simulator/ddx" value="$dy"/>
          </admst:when>
          <admst:when test="[$y='1.0']">
            <admst:value-to select="/simulator/ddx" value="$dx"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="/simulator/ddx" value="(($dx*$y)+($x*$dy))"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:choose>
          <admst:when test="[$x='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:choose>
              <admst:when test="[$dy='1.0']">
                <admst:value-to select="/simulator/ddx" value="(-1/($y*$y))"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-to select="/simulator/ddx" value="(-$dy/($y*$y))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:choose>
              <admst:when test="[$dy='1.0']">
                <admst:value-to select="/simulator/ddx" value="(-$x/($y*$y))"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-to select="/simulator/ddx" value="(-($x*$dy)/($y*$y))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$dx='1.0']">
            <admst:choose>
              <admst:when test="[$dy='0.0']">
                <admst:value-to select="/simulator/ddx" value="(1./$y)"/>
              </admst:when>
              <admst:when test="[$dy='1.0']">
                <admst:value-to select="/simulator/ddx" value="(($y-$x)/($y*$y))"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-to select="/simulator/ddx" value="(($y-($x*$dy))/($y*$y))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="[$y='1.0']">
                <admst:value-to select="/simulator/ddx" value="$dx"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:value-to select="/simulator/ddx" value="$dx/$y"/>
              </admst:when>
              <admst:when test="[$dy='1.0']">
                <admst:value-to select="/simulator/ddx" value="(($dx*$y)-$x)/($y*$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-to select="/simulator/ddx" value="($dx*$y-$x*$dy)/($y*$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:value-to select="/simulator/ddx" value=""/>
      </admst:otherwise>
    </admst:choose>
  </admst:if>

</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="mapply_ternary">
<admst:message test="[/dbg_xml='yes']" format="*mapply_ternary*\n"/>
  <admst:apply-templates select="arg3" match="stringify_expression"/>
  <admst:value-of select="/simulator/ddx"/>
  <admst:variable name="dz" select="%s"/>
  <admst:apply-templates select="arg2" match="stringify_expression"/>
  <admst:value-of select="/simulator/ddx"/>
  <admst:variable name="dy" select="%s"/>
  <admst:apply-templates select="arg1" match="stringify_expression"/>
  <admst:variable name="x" select="%s"/>
  <admst:value-to select="/simulator/tmp" value="($x?%s:%s)"/>
  <admst:if test="/simulator/probe">
    <admst:value-to select="/simulator/ddx" value="($x?$dy:$dz)"/>
  </admst:if>
</admst:template>

<!-- *********************************************************************************** -->
<!-- ******************************* tree traverse ************************************* -->
<!-- *********************************************************************************** -->

<!-- ----------------------------------------------------------------- -->
<admst:template match="function">
  <admst:choose>
    <admst:when test="[name='ddt']">
      <admst:for-each select="arguments[position(.)=1]">
        <admst:apply-templates select="." match="stringify_expression"/>
        <admst:value-to select="/simulator/tmp" value="%s"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="[name='\$given']">
      <admst:for-each select="arguments[position(.)=1]">
        <admst:if test="adms[datatypename!='variable']">
          <admst:error format="$given: argument is not a variable\n"/>
        </admst:if>
        <admst:if test="[input='no']">
          <admst:value-of select="name"/>
          <admst:error format="$given(%s): argument is not a parameter\n"/>
        </admst:if>
        <admst:choose>
          <admst:when test="[parametertype='model']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/tmp" value="_model->IsParamGiven(&quot;%s&quot;)"/>
          </admst:when>
          <admst:when test="[parametertype='instance']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/tmp" value="IsParamGiven(&quot;%s&quot;)"/>
          </admst:when>
          <admst:otherwise>
            <admst:error format="$given(%s): should not be reached\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$model']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="%s"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$instance']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="%s"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$temperature']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="%s"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$nominal_temperature']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="%s"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
       <admst:when test="arguments">
        <admst:choose>
         <admst:when test="arguments[count(.)=1]">
          <admst:apply-templates select="." match="function:assert:onearg"/>
          <admst:for-each select="arguments[position(.)=1]">
            <admst:apply-templates select="." match="stringify_expression"/>
            <admst:value-to select="/simulator/tmp" value="_vt(%s)"/>
          </admst:for-each>
         </admst:when>
         <admst:otherwise>
           <admst:error format="$vt(...): too many args"/>   
         </admst:otherwise>
        </admst:choose>
       </admst:when>
       <admst:otherwise>
         <admst:apply-templates select="." match="function:assert:noarg"/>
         <admst:value-to select="/simulator/tmp" value="_vt_nom"/>   
       </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='\$scale']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:value-to select="/simulator/tmp" value="_scale"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$abstime']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:value-to select="/simulator/tmp" value="_abstime"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$options']">
      <admst:for-each select="arguments[position(.)=1]">
        <admst:if test="adms[datatypename!='string']">
          <admst:error format="$given: argument is not a string\n"/>
        </admst:if>
        <admst:choose>
          <admst:when test="[value='OPTm_hier']">
            <admst:value-to select="/simulator/tmp" value="_circuit_m_hier"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-of select="value"/>
            <admst:fatal format="$options(%s): bad argument []\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='ddx' or name='\$derivate']">
      <admst:for-each select="arguments"> 
        <admst:if test="[position(.)=2]">
          <admst:if test="adms[datatypename!='probe']">
            <admst:value-of select="../name"/>
            <admst:error format="%s: second argument is not a probe\n"/>
          </admst:if>
          <admst:value-of select="branch/nnode/name"/>
          <admst:value-of select="branch/pnode/name"/>
          <admst:value-of select="nature/access"/>
        </admst:if>
      </admst:for-each>
      <admst:for-each select="arguments"> 
        <admst:if test="[position(.)=1]">
          <admst:if test="adms[datatypename!='variable']">
            <admst:value-of select="../name"/>
            <admst:error format="%s: first argument is not a variable\n"/>
          </admst:if>
          <admst:value-of select="name"/>
        </admst:if>
      </admst:for-each>
      <admst:value-to select="/simulator/tmp" value="%s_%s%s_%s"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='floor']">
      <admst:apply-templates select="." match="function:assert:onearg"/>
      <admst:for-each select="arguments[position(.)=1]">
        <admst:apply-templates select="." match="stringify_expression"/>
        <admst:value-to select="/simulator/tmp" value="floor(%s)"/>
      </admst:for-each>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='ceil']">
      <admst:apply-templates select="." match="function:assert:onearg"/>
      <admst:for-each select="arguments[position(.)=1]">
        <admst:apply-templates select="." match="stringify_expression"/>
        <admst:value-to select="/simulator/tmp" value="ceil(%s)"/>
      </admst:for-each>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='pow' or name='hypot' or name='min' or name='max']">
      <admst:value-of select="index(./subexpression/expression/function,.)"/>
      <admst:variable name="index" select="%s"/>
      <admst:if test="/simulator/probe">
        <admst:for-each select="arguments"> 
          <admst:choose>
            <admst:when test="[position(.)=1]">
              <admst:apply-templates select="." match="stringify_expression"/>
              <admst:variable name="x" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dx" select="%s"/>
            </admst:when>
            <admst:when test="[position(.)=2]">
              <admst:apply-templates select="." match="stringify_expression"/>
              <admst:variable name="y" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dy" select="%s"/>
            </admst:when>
            <admst:otherwise>
              <admst:count select="../arguments"/>
              <admst:value-of select="../name"/>
              <admst:error format="%s(...): two arguments expected - %s found(s) \n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
        <admst:choose>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/ddx" value="(__dFy_%s_$index*$dy)"/>
          </admst:when>
          <admst:when test="[$dy='0.0']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/ddx" value="(__dFx_%s_$index*$dx)"/>
          </admst:when>
          <admst:otherwise>
            <admst:apply-templates select="." match="function:getname"/>
            <admst:apply-templates select="." match="function:getname"/>
            <admst:value-to select="/simulator/ddx" value="(__dFx_%s_$index*$dx+__dFy_%s_$index*$dy)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="__%s_$index"/>
    </admst:when>
    <admst:when test="[name='div']">
      <admst:value-of select="index(./subexpression/expression/function,.)"/>
      <admst:variable name="index" select="%s"/>
      <admst:if test="/simulator/probe">
        <admst:for-each select="arguments"> 
          <admst:choose>
            <admst:when test="[position(.)=1]">
              <admst:apply-templates select="." match="stringify_expression"/>
              <admst:variable name="x" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dx" select="%s"/>
            </admst:when>
            <admst:when test="[position(.)=2]">
              <admst:apply-templates select="." match="stringify_expression"/>
              <admst:variable name="y" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dy" select="%s"/>
            </admst:when>
            <admst:otherwise>
              <admst:count select="../arguments"/>
              <admst:value-of select="../name"/>
              <admst:error format="%s(...): two arguments expected - %s found(s) \n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
        <admst:choose>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:value-to select="/simulator/ddx" value="(__dFy_%(name)_$index*$dy)"/>
          </admst:when>
          <admst:when test="[$dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="(__dFx_%(name)_$index*$dx)"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="/simulator/ddx" value="(__dFx_%(name)_$index*$dx+__dFy_%(name)_$index*$dy)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="__%s_$index"/>
    </admst:when>
    <admst:when test="[class='builtin']">
      <admst:value-of select="index(./subexpression/expression/function,.)"/>
      <admst:variable name="index" select="%s"/>
      <admst:if test="/simulator/probe">
        <admst:for-each select="arguments"> 
          <admst:choose>
            <admst:when test="[position(.)=1]">
              <admst:apply-templates select="." match="stringifry_expression"/>
              <admst:variable name="x" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dx" select="%s"/>
            </admst:when>
            <admst:otherwise>
              <admst:count select="../arguments"/>
              <admst:value-of select="../name"/>
              <admst:error format="%s(...): one argument expected - %s found(s) \n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
        <admst:choose>
          <admst:when test="[$dx='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:apply-templates select="." match="function:getname"/>
            <admst:value-to select="/simulator/ddx" value="$dx*__d_%s_$index"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="__%s_$index"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[name='\$simparam']">
           <admst:apply-templates select="." match="function:simparam"/>
        </admst:when>
        <admst:when test="[name='analysis']">
           <admst:apply-templates select="." match="function:analysis"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-of select="name"/>
          <admst:variable name="function" select="%s"/>
          <admst:variable name="args" select=""/>
          <admst:for-each select="arguments">
            <admst:value-of select="position(.)"/>
            <admst:variable name="index" select="%s"/>
            <admst:if test="[not($args='')]">
              <admst:variable name="args" select="$args,"/>
            </admst:if>
            <admst:apply-templates select="." match="stringify_expression"/>
            <admst:variable name="arg$index" select="%s"/>
            <admst:variable name="args" select="$args$(arg$index)"/>
          </admst:for-each>
          <admst:value-to select="/simulator/tmp" value="$function($args)"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dargs" select="$args"/>
            <admst:for-each select="arguments">
              <admst:apply-templates select="." match="stringify_expression"/>
              <admst:variable name="x" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dargs" select="$dargs,%s"/>
            </admst:for-each>
            <admst:value-to select="/simulator/ddx" value="d_$function($dargs)"/>
          </admst:if>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="contribution:nonoise">
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:text format="#if defined(_DYNAMIC)\n"/>
      </admst:when>
    </admst:choose>
    <admst:text format="{\n"/>
    <admst:for-each select="rhs/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="." match="ddx:function:computation"/>
  </admst:if>
  <admst:apply-templates select="rhs/tree" match="stringify_expression"/>
  <admst:choose>
    <admst:when test="[dynamic='yes']">
      <admst:text format="  _load_dynamic_"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  _load_static_"/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="lhs/branch/nnode[grounded='no']">
      <admst:value-of select="lhs/branch/nnode/name"/>
      <admst:value-of select="lhs/branch/pnode/name"/>
      <admst:text format="residual2(%s,%s,%s)\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="lhs/branch/pnode/name"/>
      <admst:text format="residual1(%s,%s)\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:for-each select="rhs/probe">
    <admst:value-of select="."/>
    <admst:value-to select="/simulator/probe" value="%p"/>
    <admst:apply-templates select="../tree" match="subexpression:differentiate"/>
    <admst:value-of select="/simulator/ddx"/>
    <admst:choose>
      <admst:when test="..[dynamic='yes']">
        <admst:text format="  _load_dynamic_"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="  _load_static_"/>
      </admst:otherwise>
    </admst:choose>
    <admst:if test="branch/pnode[grounded='no']">
      <admst:if test="../../lhs/branch/pnode[grounded='no']">
        <admst:choose>
          <admst:when test="branch/nnode[grounded='no']">
            <admst:if test="../../lhs/branch/nnode[grounded='no']">
              <admst:value-of select="branch/nnode/name"/>
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/nnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian4(%s,%s,%s,%s,%s)\n"/>
            </admst:if>
            <admst:if test="../../lhs/branch/nnode[grounded='yes']">
              <admst:value-of select="branch/nnode/name"/>
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian2p(%s,%s,%s,%s)\n"/>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:if test="../../lhs/branch/nnode[grounded='no']">
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/nnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian2s(%s,%s,%s,%s)\n"/>
            </admst:if>
            <admst:if test="../../lhs/branch/nnode[grounded='yes']">
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian1(%s,%s,%s)\n"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:if>
  </admst:for-each>
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:text format="}\n"/>
    <admst:if test="[dynamic='yes']">
      <admst:text format="#endif /* _DYNAMIC */\n"/>
    </admst:if>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="function:assert:noarg">
<admst:message test="[/dbg_xml='yes']" format="*function:assert:noarg*\n"/>
  <admst:if test="[not(nilled(arguments))]">
    <admst:value-of select="name"/>
    <admst:error format="%s: should not have arguments\n"/>
  </admst:if>
</admst:template>
<admst:template match="function:assert:onearg">
<admst:message test="[/dbg_xml='yes']" format="*function:assert:onearg*\n"/>
  <admst:if test="arguments[not(count(.)=1)]">
    <admst:value-of select="name"/>
    <admst:error format="%s: should have one argument exactly\n"/>
  </admst:if>
</admst:template>

<!-- expression//function: mapping verilog-name == C-name of function -->
<!-- ----------------------------------------------------------------- -->
<admst:template match="function:getname">
<admst:message test="[/dbg_xml='yes']" format="*function:getname*\n"/>
  <admst:choose>
    <admst:when test="[name='abs']"><admst:value-of select="'fabs'"/></admst:when>
    <admst:when test="[name='log']"><admst:value-of select="'log10'"/></admst:when>
    <admst:when test="[name='ln']"><admst:value-of select="'logE'"/></admst:when>
    <admst:when test="[name='limexp']"><admst:value-of select="'limexp'"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:value-of select="'limexp'"/></admst:when>
    <admst:when test="[name='\$model']"><admst:value-of select="'_modelname'"/></admst:when>
    <admst:when test="[name='\$instance']"><admst:value-of select="'_instancename'"/></admst:when>
    <admst:when test="[name='\$temperature']"><admst:value-of select="'_circuit_temp'"/></admst:when>
    <admst:otherwise><admst:value-of select="name"/></admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="function:analysis">
<admst:message test="[/dbg_xml='yes']" format="*function:analysis*\n"/>
  <admst:value-of select="name"/>
  <admst:variable name="function" select="%s"/>
  <admst:variable name="args" select=""/>
  <admst:for-each select="arguments">
    <admst:value-of select="position(.)"/>
    <admst:variable name="index" select="%s"/>
    <admst:if test="[not($args='')]">
      <admst:variable name="args" select="$args,"/>
    </admst:if>
    <admst:apply-templates select="." match="stringify_expression"/>
    <admst:variable name="arg$index" select="%s"/>
    <admst:variable name="args" select="$args$(arg$index)"/>
  </admst:for-each>
  <admst:choose>
    <admst:when test="[$arg1='&quot;noise&quot;']">
      <admst:value-to select="/simulator/tmp" value="0.0"/>
      <admst:error format="$function($args): replaced by 0.0\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:error format="$function($args) -- not implemented in ngspice interface\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="function:simparam">
<admst:message test="[/dbg_xml='yes']" format="*function:simparam*\n"/>
  <admst:value-of select="name"/>
  <admst:variable name="function" select="%s"/>
  <admst:variable name="args" select=""/>
  <admst:for-each select="arguments">
    <admst:value-of select="position(.)"/>
    <admst:variable name="index" select="%s"/>
    <admst:if test="[not($args='')]">
      <admst:variable name="args" select="$args,"/>
    </admst:if>
    <admst:apply-templates select="." match="stringify_expression"/>
    <admst:variable name="arg$index" select="%s"/>
    <admst:variable name="args" select="$args$(arg$index)"/>
  </admst:for-each>
  <admst:choose>
    <admst:when test="[$arg1='&quot;gdev&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_gdev"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;gmin&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_gmin"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;imax&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_imax"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;imelt&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_imelt"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;iteration&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_iteration"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;scale&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_scale"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;shrink&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_shrink"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;simulatorSubversion&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_simulatorSubversion"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;simulatorVersion&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_simulatorVersion"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;sourceScaleFactor&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_sourceScaleFactor"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;tnom&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_tnom"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;checkjcap&quot;']">
      <admst:value-to select="/simulator/tmp" value="1.0"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;maxmosl&quot;']">
      <admst:value-to select="/simulator/tmp" value="1.0"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;maxmosw&quot;']">
      <admst:value-to select="/simulator/tmp" value="1.0"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;minmosl&quot;']">
      <admst:value-to select="/simulator/tmp" value="1.0e-12"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;minmosw&quot;']">
      <admst:value-to select="/simulator/tmp" value="1.0e-12"/>
    </admst:when>
    <admst:otherwise>
      <admst:error format="$function($args) -- not implemented in ngspice interface\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="variable:declaration">
<admst:message test="[/dbg_xml='yes']" format="*variable:declaration*\n"/>
  <admst:for-each select="module/evaluation/variable">
    <admst:assert test="adms[datatypename='variable']" format="expecting datatypename=variable\n"/>
    <admst:if test="[scope='local']">
      <admst:if test="[static='no' and dynamic='yes']">#if defined(_DYNAMIC)\n</admst:if>
      <admst:value-of select="name"/>
      <admst:if test="[type='integer']">int %s;\n</admst:if>
      <admst:if test="[type='real']">double %s=0.0/0.0;\n</admst:if>
      <admst:if test="[type='string']">char* %s;\n</admst:if>
      <admst:if test="[insource='yes']">
        <admst:if test="probe">
			  <admst:text format="#if defined(_DERIVATE) // BAR\n"/>
          <admst:for-each select="probe">
            <admst:value-of select="branch/nnode/name"/>
            <admst:value-of select="branch/pnode/name"/>
            <admst:value-of select="nature/access"/>
            <admst:value-of select="../name"/>
            <admst:text format="double %s_%s%s_%s=0.0;\n"/>
          </admst:for-each>
          <admst:text format="#endif /*_DERIVATE*/\n"/>
        </admst:if>
      </admst:if>
      <admst:if test="[static='no' and dynamic='yes']">#endif /*_DYNAMIC*/\n</admst:if>
    </admst:if>
    <admst:if test="[scope!='local']">
      <admst:if test="[insource='yes']">
        <admst:if test="probe">
			  <!-- admst:text format="#if defined(_DERIVATE) // BLI\n"/ -->
          <admst:if test="[$_DERIVATE='yes']"> 
				 <admst:for-each select="probe">
					<admst:value-of select="branch/nnode/name"/>
					<admst:value-of select="branch/pnode/name"/>
					<admst:value-of select="nature/access"/>
					<admst:value-of select="../name"/>
					<admst:text format="double %s_%s%s_%s=0.0;\n"/>
				 </admst:for-each>
				 <!--admst:text format="#endif /*_DERIVATE*/\n"/-->

			  </admst:if>
        </admst:if>
      </admst:if>
    </admst:if>
  </admst:for-each>
  <admst:reset select="module/evaluation/variable"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- save all variables used for local declaration -->
<admst:template match="block:local:declaration">
<admst:message test="[/dbg_xml='yes']" format="*block:local:declaration*\n"/>
  <admst:text format="// block:local:declaration\n"/>
  <admst:choose>
    <admst:when test="adms[datatypename='assignment']">
      <admst:push into="module/evaluation/variable" select="lhs" onduplicate="ignore"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:for-each select="item">
        <admst:apply-templates select="." match="block:local:declaration" required="yes"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="then" match="block:local:declaration" required="yes"/>
      <admst:apply-templates select="else" match="block:local:declaration" required="yes"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="block:local:declaration" required="yes"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
    </admst:when>
    <admst:when test="adms[datatypename='callfunction']">
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:error format="case statement: please implement me! (local declaration)\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:value-of select="admst(.)"/>
      <admst:value-of select="adms/datatypename"/>
      <admst:error format="'datatypename=%s': should not be reached %s\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- analog//blockvariable -->
<admst:template match="blockvariable">
<admst:message test="[/dbg_xml='yes']" format="*blockvariable*\n"/>
  <admst:for-each select="variable">
    <admst:if test="[type='integer']">int %(name);\n</admst:if>
    <admst:if test="[type='real']">double %(name);\n</admst:if>
    <admst:if test="[type='string']">char* %(name);\n</admst:if>
    <admst:text test="[insource='yes']" select="probe" format="double %(../name)_%(nature/access)%(branch/pnode/name)_%(branch/nnode/name);\n"/>
  </admst:for-each>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- analog//block -->
<admst:template match="block">
<admst:message test="[/dbg_xml='yes']" format="*block*\n"/>
  <admst:assert test="[name!='/']" format="expecting subblock\n"/>
  <admst:text format="{\n"/>
  <admst:for-each select="item">
    <admst:value-of select="./adms/datatypename"/>
    <admst:apply-templates select="." match="%s" required="yes"/>
  </admst:for-each>
  <admst:text format="}\n"/>
</admst:template>

<!-- from here is not guesstopology, but model_initialize, at least next 2 functions  -->
<!-- ----------------------------------------------------------------- -->
<!-- analog/[initializeModel|initializeInstance|initial_model|initial_instance|initial_step|noise] -->
<admst:template match="block:initial">
<admst:message test="[/dbg_xml='yes']" format="*block:initial*\n"/>
  <admst:assert test="adms[datatypename='block']" format="expecting datatypename=block\n"/>
  <admst:apply-templates select="." match="block:local:declaration"/>
  <admst:apply-templates select="." match="variable:declaration"/>
  <admst:apply-templates select="." match="block" required="yes"/>
</admst:template>
<admst:template match="analog:initial_instance">
<admst:message test="[/dbg_xml='yes']" format="*analog:initial_instance*\n"/>
  <admst:if test="code">
    <admst:if test="code/adms[datatypename='block']">
      <admst:for-each select="code/item">
        <admst:if test="adms[datatypename='block']">
			  <admst:apply-templates select="[name='initial_instance' or name='initializeInstance']" 
				  match="block:initial"/>
        </admst:if>
      </admst:for-each>
    </admst:if>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="analog:initial_model">
<admst:message test="[/dbg_xml='yes']" format="*analog:initial_model*\n"/>
  <admst:if test="code">
    <admst:if test="code/adms[datatypename='block']">
      <admst:for-each select="code/item">
        <admst:if test="adms[datatypename='block']">
			  <admst:apply-templates select="[name='initial_model' or name='initializeModel']" 
				  match="block:initial"/>
        </admst:if>
      </admst:for-each>
    </admst:if>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="analog:initial_step">
<admst:message test="[/dbg_xml='yes']" format="*analog:initial_step*\n"/>
  <admst:if test="code">
    <admst:if test="code/adms[datatypename='block']">
      <admst:for-each select="code/item">
        <admst:if test="adms[datatypename='block']">
          <admst:apply-templates select="[name='initial_step']" match="block:initial"/>
        </admst:if>
      </admst:for-each>
    </admst:if>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="analog:noise">
<admst:message test="[/dbg_xml='yes']" format="*analog:noise*\n"/>
  <admst:if test="code">
    <admst:if test="code/adms[datatypename='block']">
      <admst:for-each select="code/item">
        <admst:if test="adms[datatypename='block']">
          <admst:apply-templates select="[name='noise']" match="block:initial"/>
        </admst:if>
      </admst:for-each>
    </admst:if>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- analog//function: local assignment handling -->
<admst:template match="function:assignment">
<admst:message test="[/dbg_xml='yes']" format="*function:assignment*\n"/>
  <admst:for-each select="function[class='builtin']">
    <admst:choose>
      <admst:when test="arguments[count(.)=1]">
        <admst:value-of select="position(.)-1"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:text format="_%s(__%s_%s,"/>
        <admst:join select="arguments" separator=",">
          <admst:apply-templates select="." match="stringify_expression"/>
          <admst:text format="(%s)"/>
        </admst:join>
        <admst:text format=")\n"/>
        <admst:value-of select="position(.)-1"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:text format="EXIT_IF_ISNAN(__%s_%s)\n"/>
      </admst:when>
      <admst:when test="arguments[count(.)=2]">
        <admst:value-of select="position(.)-1"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:text format="_%s"/>
        <admst:text test="[name='div']" format="0"/>
        <admst:text format="(__%s_%s,"/>
        <admst:join select="arguments" separator=",">
          <admst:apply-templates select="." match="stringify_expression"/>
          <admst:text format="%s"/>
        </admst:join>
        <admst:text format=")\n"/>
        <admst:value-of select="position(.)-1"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:text format="EXIT_IF_ISNAN(__%s_%s)\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:value-of select="name"/>
        <admst:error format="%s: function not handled\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- analog//function: ddx handling -->
<admst:template match="ddx:function:computation">
<admst:message test="[/dbg_xml='yes']" format="*ddx:function:computation*\n"/>
  <admst:if test="lhs[insource='yes']">
    <admst:if test="rhs[hasVoltageDependentFunction='yes']">
      <admst:text format="#if defined(_DERIVATE)\n"/>
      <admst:for-each select="rhs/function">
        <admst:if test="arguments[count(.)=1]">
          <admst:for-each select="arguments[position(.)=1]">
            <admst:if test="math[dependency!='constant']">
              <admst:value-of select="../position(.)-1"/>
              <admst:apply-templates select=".." match="function:getname"/>
              <admst:text format="double __d_%s_%s=0.0;\n"/>
            </admst:if>
          </admst:for-each>
        </admst:if>
        <admst:if test="arguments[count(.)=2]">
          <admst:for-each select="arguments">
            <admst:if test="[position(.)=1]">
              <admst:if test="[(../name='div') or (math/dependency!='constant')]">
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="double __dFx_%s_%s=0.0;\n"/>
              </admst:if>
            </admst:if>
            <admst:if test="[position(.)=2]">
              <admst:if test="math[dependency!='constant']">
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="double __dFy_%s_%s=0.0;\n"/>
              </admst:if>
            </admst:if>
          </admst:for-each>
        </admst:if>
      </admst:for-each>
      <admst:text format="#endif /* _DERIVATE */\n"/>
      <admst:text format="#if defined(_DERIVATE)\n"/>
      <admst:for-each select="rhs/function">
        <admst:if test="arguments[count(.)=1]">
          <admst:for-each select="arguments[position(.)=1]">
            <admst:apply-templates select="." match="stringify_expression"/>
            <admst:choose>
              <admst:when test="math[dependency!='constant']">
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="_d_%s(__%s_%s,__d_%s_%s,(%s))\n"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="EXIT_IF_ISNAN(__%s_%s)\n"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="EXIT_IF_ISNAN(__d_%s_%s)\n"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="_%s(__%s_%s,(%s))\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:if>
        <admst:if test="arguments[count(.)=2]">
          <admst:value-of select="./position(.)-1"/>
          <admst:apply-templates select="." match="function:getname"/>
          <admst:apply-templates select="." match="function:getname"/>
          <admst:text format="_%s(__%s_%s,"/>
          <admst:text test="[name='div']" format="__dFx_%(name)_%(position(.)-1),"/>
          <admst:join select="arguments" separator=",">
            <admst:apply-templates select="." match="stringify_expression"/>
            <admst:text format="%s"/>
          </admst:join>
          <admst:text format=")\n"/>
          <admst:for-each select="arguments">
            <admst:if test="[position(.)=1]">
              <admst:if test="math[dependency!='constant']">
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="_dx_%s(__dFx_%s_%s,__%s_%s,"/>
                <admst:join select="../arguments" separator=",">
                  <admst:apply-templates select="." match="stringify_expression"/>
                  <admst:text format="%s"/>
                </admst:join>
                <admst:text format=")\n"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="EXIT_IF_ISNAN(__dFx_%s_%s)\n"/>
              </admst:if>
            </admst:if>
            <admst:if test="[position(.)=2]">
              <admst:if test="math[dependency!='constant']">
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="_dy_%s(__dFy_%s_%s,"/>
                <admst:text test="[../name='div']" format="__dFx_%(../name)_%(../position(.)-1),"/>
                <admst:text format="__%s_%s,"/>
                <admst:join select="../arguments" separator=",">
                  <admst:apply-templates select="." match="stringify_expression"/>
                  <admst:text format="%s"/>
                </admst:join>
                <admst:text format=")\n"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="EXIT_IF_ISNAN(__dFy_%s_%s)\n"/>
              </admst:if>
            </admst:if>
          </admst:for-each>
          <admst:value-of select="position(.)-1"/>
          <admst:apply-templates select="." match="function:getname"/>
          <admst:text format="EXIT_IF_ISNAN(__%s_%s)\n"/>
        </admst:if>
      </admst:for-each>
      <admst:text format="#else\n"/>
    </admst:if>
  </admst:if>
  <admst:apply-templates select="rhs" match="function:assignment"/>
  <admst:if test="lhs[insource='yes']">
    <admst:if test="rhs[hasVoltageDependentFunction='yes']">
      <admst:text format="#endif\n"/>
    </admst:if>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- analog//assignment -->
<admst:template match="assignment">
<admst:message test="[/dbg_xml='yes']" format="*assignment: %(.)*\n"/>
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:text format="#if defined(_DYNAMIC)\n"/>
      </admst:when>
    </admst:choose>
    <admst:text format="{\n"/>
    <admst:for-each select="rhs/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="." match="ddx:function:computation"/>
  </admst:if>
  <admst:if test="lhs[derivate='yes']">
    <admst:text format="#if defined(_DERIVATE)\n"/>
  </admst:if>
  <admst:if test="lhs[insource='yes']">
    <admst:if test="rhs/probe">
      <admst:text format="#if defined(_DERIVATE)\n"/>
      <admst:for-each select="rhs/probe">
        <admst:value-of select="."/>
        <admst:value-to select="/simulator/probe" value="%p"/>
        <admst:apply-templates select="../tree" match="subexpression:differentiate"/>
        <admst:value-of select="/simulator/ddx"/>
        <admst:value-of select="branch/nnode/name"/>
        <admst:value-of select="branch/pnode/name"/>
        <admst:value-of select="nature/access"/>
        <admst:value-of select="../../lhs/name"/>
        <admst:text format="%s_%s%s_%s=%s;\n"/>
        <admst:value-of select="branch/nnode/name"/>
        <admst:value-of select="branch/pnode/name"/>
        <admst:value-of select="nature/access"/>
        <admst:value-of select="../../lhs/name"/>
        <admst:text format="EXIT_IF_ISNAN(%s_%s%s_%s)\n"/>
      </admst:for-each>
      <admst:text format="#endif /*_DERIVATE*/\n"/>
    </admst:if>
  </admst:if>
  <admst:choose>
    <admst:when test="[dynamic='yes']">
      <admst:text format="#if defined(_DYNAMIC)\n"/>
    </admst:when>
  </admst:choose>
  <admst:apply-templates select="lhs" match="variable:lhs" required="yes"/>
  <admst:apply-templates select="rhs/tree" match="stringify_expression"/>
  <admst:text format="=%s;\n"/>
  <admst:text format="EXIT_IF_ISNAN("/>
  <admst:apply-templates select="lhs" match="variable:lhs" required="yes"/>
  <admst:text format=")\n"/>
  <admst:choose>
    <admst:when test="[dynamic='yes']">
      <admst:text format="#endif /*_DYNAMIC*/\n"/>
    </admst:when>
  </admst:choose>
  <admst:if test="lhs[derivate='yes']">
    <admst:text format="#endif /*_DERIVATE*/\n"/>
  </admst:if>
  <admst:if test="lhs[insource='yes']">
    <admst:value-of select="rhs/probe"/>
    <admst:if-inside select="lhs/probe" list="%p">
      <admst:if test="lhs/probe">
        <admst:text format="#if defined(_DERIVATE)\n"/>
        <admst:for-each select="lhs/probe">
          <admst:value-of select="../../rhs/probe"/>
          <admst:if-not-inside select="." list="%p">
            <admst:value-of select="branch/nnode/name"/>
            <admst:value-of select="branch/pnode/name"/>
            <admst:value-of select="nature/access"/>
            <admst:value-of select="../name"/>
            <admst:text format="%s_%s%s_%s=0.0;\n"/>
          </admst:if-not-inside>
        </admst:for-each>
        <admst:text format="#endif /*_DERIVATE*/\n"/>
      </admst:if>
    </admst:if-inside>
  </admst:if>
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:text format="}\n"/>
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:text format="#endif /* _DYNAMIC */\n"/>
      </admst:when>
    </admst:choose>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- ---------- analog//tr_eval_kept ------------------------------- -->
<admst:template match="tr_eval_kept">
<admst:message test="[/dbg_xml='yes']" format="*tr_eval_kept*\n"/>
  <admst:variable name="eval_kept" select="yes"/>
  <admst:variable name="keep_ic" select="no"/>


  <admst:text format="// var decl\n"/>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:text format="// var decl done\n"/>


  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:choose>
      <admst:when test="adms[datatypename!='block']">
        <admst:text format="// not a block\n"/>
        <admst:text format="// fetch states\n"/>
        <admst:apply-templates select="." match="%(adms/datatypename)"/>
        <admst:text format="// fetched states\n"/>
        <admst:text format="// not a block done\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:if test="[name!='initial_model' and name!='initial_instance']">
          <admst:text format="// not initial_\n"/>

          <admst:text format="{ //block \n"/>
          <admst:text select="item" format=" // %(adms/datatypename) \n"/>
          <admst:apply-templates select="item" match="%(adms/datatypename)"/>
          <admst:text format="} //blovk... \n"/>

          <admst:text format="// done block\n"/>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
  <admst:variable name="eval_kept" select="no"/>
  <admst:variable name="keep_ic" select="no"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- ---------- analog//keep_ic ------------------------------- -->
<admst:template match="keep_ic">
<admst:message test="[/dbg_xml='yes']" format="*keep_ic*\n"/>
  <admst:message format=" //keep_ic have here: %(adms/datatypename) name %(name)\n"/>
  <admst:for-each select="item">
    <!-- <admst:message format=" //keep_ic looking around: have here: %(adms/datatypename) name %(name): %(.)\n"/>
    -->
  </admst:for-each>

  <admst:variable name="keep_ic" select="yes"/>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:choose>
      <admst:when test="adms[datatypename!='block']">
        <admst:text format="// not a block\n"/>
        <admst:warning format="keep ic takes a block, not %(adms/datatypename) - %(.)\n"/>
        <!-- <admst:apply-templates select="." match="%(adms/datatypename)"/> -->
        <admst:text format="// not a block done\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:if test="[name!='initial_model' and name!='initial_instance']">
          <admst:text format="// not initial_\n"/>
          <!-- <admst:apply-templates select="." match="block"/> -->

          <admst:text format="{ //block \n"/>


          <admst:apply-templates select="item" match="%(adms/datatypename)"/>
          <admst:text format="} //blovk. \n"/>

          <admst:text format="// done block\n"/>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
  <admst:variable name="keep_ic" select="no"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- ---------- analog//contribution ------------------------------- -->
<admst:template match="ac_load">
<admst:message test="[/dbg_xml='yes']" format="*ac_load*\n"/>
  incomplete();
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- ---------- analog//contribution ------------------------------- -->

<admst:template match="contribution">
<admst:message test="[/dbg_xml='yes']" format="*contribution*\n"/>
  <admst:choose>
    <admst:when test="[whitenoise='no' and flickernoise='no']">
      <admst:apply-templates select="." match="contribution:nonoise" required="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="." match="contribution:noise" required="yes"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- ----------------------  analog//conditional ------------------ -->
<admst:template match="conditional">
<admst:message test="[/dbg_xml='yes']" format="*conditional*\n"/>
  <admst:if test="if[dynamic='yes']">
    <admst:choose>
      <admst:when test="[nilled(else)]">
        <admst:text format="#ifdef _DYNAMIC /*&lt;dynamic_ifthen&gt;*/\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="#ifdef _DYNAMIC /*&lt;dynamic_ifthenelse&gt;*/\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:if>
  <admst:if test="if[not(nilled(function[class='builtin']))]">
    <admst:text format="{\n"/>
    <admst:for-each select="if/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="if" match="function:assignment"/>
  </admst:if>
  <admst:apply-templates select="if/tree" match="stringify_expression"/>
  <admst:text format="if\n(%s)\n"/>
  <admst:if test="then/adms[datatypename!='block']">
    <admst:text format="{\n"/>
  </admst:if>
  <admst:value-of select="then/adms/datatypename"/>
  <admst:apply-templates select="then" match="%s" required="yes"/>
  <admst:if test="then/adms[datatypename!='block']">
    <admst:text format="}\n"/>
  </admst:if>
  <admst:if test="else">
    <admst:text format="else\n"/>
    <admst:choose>
      <admst:when test="else/adms[datatypename='block']">
        <admst:value-of select="else/adms/datatypename"/>
        <admst:apply-templates select="else" match="%s" required="yes"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="{\n"/>
        <admst:value-of select="else/adms/datatypename"/>
        <admst:apply-templates select="else" match="%s" required="yes"/>
        <admst:text format="}\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:if>
  <admst:if test="if[not(nilled(function[class='builtin']))]">
    <admst:text format="}\n"/>
  </admst:if>
  <admst:if test="if[dynamic='yes']">
    <admst:choose>
      <admst:when test="[nilled(else)]">
        <admst:text format="#endif /*&lt;/dynamic_ifthen&gt;*/\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="#endif /*&lt;/dynamic_ifthenelse&gt;*/\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- analog//case -->
<admst:template match="case">
<admst:message test="[/dbg_xml='yes']" format="*case*\n"/>
  <admst:error format="case statement: please implement me! (inside block)\n"/>
  <admst:text format="/*CASE*/;\n"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- analog//nilled -->
<admst:template match="nilled">
<admst:message test="[/dbg_xml='yes']" format="*nilled*\n"/>
  <admst:text format=";\n"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- analog//whileloop -->
<admst:template match="whileloop">
<admst:message test="[/dbg_xml='yes']" format="*whileloop*\n"/>
  <admst:if test="while[dynamic='yes']">
    <admst:text format="#ifdef _DYNAMIC /*&lt;dynamic_while&gt;*/\n"/>
  </admst:if>
  <admst:if test="while[not(nilled(function[class='builtin']))]">
    <admst:text format="{\n"/>
    <admst:for-each select="while/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="while" match="function:assignment"/>
  </admst:if>
  <admst:apply-templates select="while/tree" match="stringify_expression"/>
  <admst:text format="while\n(%s)\n"/>
  <admst:if test="whileblock/adms[datatypename!='block']">
    <admst:text format="{\n"/>
  </admst:if>
  <admst:value-of select="whileblock/adms/datatypename"/>
  <admst:apply-templates select="whileblock" match="%s" required="yes"/>
  <admst:if test="whileblock/adms[datatypename!='block']">
    <admst:text format="}\n"/>
  </admst:if>
  <admst:if test="while[not(nilled(function[class='builtin']))]">
    <admst:text format="}\n"/>
  </admst:if>
  <admst:if test="while[dynamic='yes']">
    <admst:text format="#endif /*&lt;/dynamic_while&gt;*/\n"/>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- expression//probe -->
<admst:template match="probe">
<admst:message test="[/dbg_xml='yes']" format="*probe*\n"/>
  <admst:choose>
    <admst:when test="branch/nnode[grounded='no']">
      <admst:value-of select="branch/nnode/name"/>
      <admst:value-of select="branch/pnode/name"/>
      <admst:value-to select="/simulator/tmp" value="BP(%s,%s)"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="branch/pnode/name"/>
      <admst:value-to select="/simulator/tmp" value="NP(n_%s)"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- expression//node -->
<admst:template match="node">
<admst:message test="[/dbg_xml='yes']" format="*node*\n"/>
  <admst:value-of select="name"/>
  <admst:error format="module node not expected here ... %s\n"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- expression//string -->
<admst:template match="string">
<admst:message test="[/dbg_xml='yes']" format="*string*\n"/>
  <admst:value-of select="value"/>
  <admst:value-to select="/simulator/tmp" value="&quot;%s&quot;"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- expression//number -->
<admst:template match="number">
<admst:message test="[/dbg_xml='yes']" format="*number*\n"/>
  <admst:choose>
    <admst:when test="[scalingunit='1']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="%s"/>
    </admst:when>
    <admst:when test="[scalingunit='E']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+18)"/>
    </admst:when>
    <admst:when test="[scalingunit='P']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+15)"/>
    </admst:when>
    <admst:when test="[scalingunit='T']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+12)"/>
    </admst:when>
    <admst:when test="[scalingunit='G']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+9)"/>
    </admst:when>
    <admst:when test="[scalingunit='M']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+6)"/>
    </admst:when>
    <admst:when test="[scalingunit='k']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+3)"/>
    </admst:when>
    <admst:when test="[scalingunit='h']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+2)"/>
    </admst:when>
    <admst:when test="[scalingunit='D']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+1)"/>
    </admst:when>
    <admst:when test="[scalingunit='d']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-1)"/>
    </admst:when>
    <admst:when test="[scalingunit='c']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-2)"/>
    </admst:when>
    <admst:when test="[scalingunit='m']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-3)"/>
    </admst:when>
    <admst:when test="[scalingunit='u']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-6)"/>
    </admst:when>
    <admst:when test="[scalingunit='n']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-9)"/>
    </admst:when>
    <admst:when test="[scalingunit='A']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-10)"/>
    </admst:when>
    <admst:when test="[scalingunit='p']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-12)"/>
    </admst:when>
    <admst:when test="[scalingunit='f']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-15)"/>
    </admst:when>
    <admst:when test="[scalingunit='a']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-18)"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="scalingunit"/>
      <admst:error format="scaling unit not supported: %s\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- analog//contribution[noise] -->
<admst:template match="contribution:noise">
<admst:message test="[/dbg_xml='yes']" format="*contribution:noise*\n"/>
  <admst:fatal format="template not in use: remved\n"/>
  <admst:if test="[flickernoise='yes']">
    <admst:text format="ngspice_flickernoise(%(lhs/branch/pnode/name),%(lhs/branch/nnode/name)"/>
    <admst:for-each select="rhs/tree/arguments">
      <admst:apply-templates select="." match="%(datatypename)"/>
      <admst:value-of select="/simulator/tmp"/>
      <admst:text format=",%s"/>
    </admst:for-each>
    <admst:text test="[count(rhs/tree/arguments)=2]" format=",NULL"/>
  </admst:if>
  <admst:if test="[whitenoise='yes']">
    <admst:text format="ngspice_whitenoise(%(lhs/branch/pnode/name),%(lhs/branch/nnode/name)"/>
    <admst:for-each select="rhs/tree/arguments">
      <admst:apply-templates select="." match="%(datatypename)"/>
      <admst:value-of select="/simulator/tmp"/>
      <admst:text format=",%s"/>
    </admst:for-each>
    <admst:text test="[count(rhs/tree/arguments)=1]" format=",NULL"/>
  </admst:if>
  <admst:text format=")\n"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- variable:rhs -->
<admst:template match="variable">
  <admst:value-of select="name"/>
  <admst:if test="[parametertype='analogfunction']">
    <admst:value-to select="/simulator/tmp" value="%s"/>
  </admst:if>
  <admst:if test="[input='yes' and parametertype='model']">
    <admst:value-to select="/simulator/tmp" value="_model-&gt;%s"/>
  </admst:if>
  <admst:if test="[input='yes' and parametertype='instance']">
    <admst:value-to select="/simulator/tmp" value="_model-&gt;%s"/>
  </admst:if>
  <admst:if test="[input='no' and scope='global_model']">
    <admst:value-to select="/simulator/tmp" value="_model-&gt;%s"/>
  </admst:if>
  <admst:if test="[input='no' and scope='global_instance']">
    <admst:value-to select="/simulator/tmp" value="$(var_prefix)%s"/>
  </admst:if>
  <admst:if test="[parametertype!='analogfunction' and scope='local']">
    <admst:value-to select="/simulator/tmp" value="%s"/>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- variable:lhs -->
<admst:template match="variable:lhs">
<admst:message test="[/dbg_xml='yes']" format="*variable:lhs*\n"/>
  <admst:text test="[input='yes' and parametertype='model']" format="_model-&gt;%(name)"/>
  <admst:text test="[input='yes' and parametertype='instance']" format="_model-&gt;%(name)"/>
  <admst:text test="[input='no' and scope='global_model']" format="_model-&gt;%(name)"/>
  <admst:text test="[input='no' and scope='global_instance']" format="$(var_prefix)%(name)"/>
  <admst:text test="[scope='local']" format="%(name)"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- handle analog//callfunctions -->
<admst:template match="callfunction">
<admst:message test="[/dbg_xml='yes']" format="*callfunction*\n"/>
  <admst:message format="the function callfunction was deleted, see git: callfunction deleted"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="generate_c:declare_variable">
<admst:message test="[/dbg_xml='yes']" format="*generate_c:declare_variable*\n"/>
	<admst:if test="[type='integer']">\tint %(name);</admst:if>
	<admst:if test="[type='real']">\tdouble %(name) = std::numeric_limits&lt;double&gt;::quiet_NaN();</admst:if>
	<admst:if test="[type='string']">\tchar* %(name);</admst:if>
    	_used(%(name));

</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- ------------------find-ddt stuff ------------>
<admst:template match="find_ddt_states">
<admst:message test="[/dbg_xml='yes']" format="*find_ddt_states*\n"/>

  <admst:message format="find_ddt_states [%(.)] type %(adms/datatypename) name %(name)\n"/>

  <admst:variable name="finddt" select="yes"/>
  <admst:variable name="ddt_type" select="a_"/>

  <admst:for-each select="item[adms/datatypename='block']" >
    <admst:apply-templates select="." match="find_ddt_states"/>
  </admst:for-each> 

  <admst:for-each select="item[adms/datatypename='assignment']" >
    <admst:apply-templates select="." match="%(adms/datatypename)"/>  
  </admst:for-each> 

  <admst:variable name="ddt_type" select="c_"/>

  <admst:text format="//now contribs... \n"/>
  <admst:for-each select="item[adms/datatypename='contribution']" >
    <admst:text format="// %(.) \n"/>
    <admst:apply-templates select="." match="%(adms/datatypename):ddt"/> 
  </admst:for-each> 

  <admst:text format="// done finddt $finddt\n"/>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- -------------------------------------------------- -->
<admst:template match="function:getCid">
<admst:message test="[/dbg_xml='yes']" format="*function:getCid*\n"/>
  <admst:fatal format="???"/>
  <admst:choose>
    <admst:when test="[name='abs']"><admst:return name="function:getname" value="abs"/></admst:when>
    <admst:when test="[name='\$shrinkl']"><admst:return name="function:getname" value="shrinkl"/></admst:when>
    <admst:when test="[name='\$shrinka']"><admst:return name="function:getname" value="shrinka"/></admst:when>
    <admst:when test="[name='log']"><admst:return name="function:getname" value="log10"/></admst:when>
    <admst:when test="[name='ln']"><admst:return name="function:getname" value="logE"/></admst:when>
    <admst:when test="[name='limexp']"><admst:return name="function:getname" value="limexp"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:return name="function:getname" value="limexp"/></admst:when>
    <admst:when test="[name='\$model']"><admst:return name="function:getname" value="_modelname"/></admst:when>
    <admst:when test="[name='\$instance']">
      <admst:return name="function:getname" value="_instancename"/>
    </admst:when>
    <admst:when test="[name='\$temperature']">
      <admst:return name="function:getname" value="_circuit_temp"/>
    </admst:when>
    <admst:when test="[name='\$nominal_temperature']">
      <admst:return name="function:getname" value="_circuit_tnom"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="name"/><admst:return name="function:getname" value="%s"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- *********************************************************************************** -->
<!-- *********************************** analog function ******************************* -->
<!-- *********************************************************************************** -->

<admst:template match="afunction:getname">
  <admst:choose>
    <admst:when test="[name='abs']"><admst:return name="afunction:getname" string="abs"/></admst:when>
    <admst:when test="[name='\$shrinkl']"><admst:return name="afunction:getname" string="shrinkl"/></admst:when>
    <admst:when test="[name='\$shrinka']"><admst:return name="afunction:getname" string="shrinka"/></admst:when>
    <admst:when test="[name='log']"><admst:return name="afunction:getname" string="log10"/></admst:when>
    <admst:when test="[name='ln']"><admst:return name="afunction:getname" string="logE"/></admst:when>
    <admst:when test="[name='limexp']"><admst:return name="afunction:getname" string="limexp"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:return name="afunction:getname" string="limexp"/></admst:when>
    <admst:when test="[name='\$vt']"><admst:return name="afunction:getname" string="vt"/></admst:when>
    <admst:when test="[name='\$model']"><admst:return name="afunction:getname" string="_modelname"/></admst:when>
    <admst:when test="[name='\$instance']"><admst:return name="afunction:getname" string="_instancename"/></admst:when>
    <admst:when test="[name='\$temperature']"><admst:return name="afunction:getname" string="_circuit_temp"/></admst:when>
    <admst:when test="[name='\$nominal_temperature']"><admst:return name="afunction:getname" string="_circuit_tnom"/></admst:when>
    <admst:otherwise><admst:return name="afunction:getname" string="%(name)"/></admst:otherwise>
  </admst:choose>
</admst:template>

<!-- -------------------------------------------------------------------- -->
<admst:template match="af:print:expression">
  <admst:choose>
    <admst:when test="adms[datatypename='expression']">
      <admst:apply-templates select="tree" match="af:print:expression">
        <admst:variable name="expression" select="%(returned('x')/value)"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:variable name="dx_%(name)" select="%(returned('dx.%(name)')/value)"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:return name="x" string="$expression"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:return name="dx.%(name)" string="$(dx_%(name))"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='probe']">
      <admst:fatal format="probe not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='variable']">
      <admst:variable name="variable" select="%(name)"/>
      <admst:return name="x" string="$variable"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:variable name="ddx" select="%(name)"/>
        <admst:choose>
          <admst:when test="[$variable='$ddx']">
            <admst:return name="dx.$ddx" string="1.0"/>
          </admst:when>
          <admst:when test="../..[input='yes']">
            <admst:return name="dx.$ddx" string="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:return name="dx.$ddx" string="$(variable)_$ddx"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>

    </admst:when>
    <admst:when test="adms[datatypename='mapply_unary']">
      <admst:if test="[name='plus']">
        <admst:variable name="op" select="+"/>
      </admst:if>
      <admst:if test="[name='minus']">
        <admst:variable name="op" select="-"/>
      </admst:if>
      <admst:if test="[name='not']">
        <admst:variable name="op" select="!"/>
      </admst:if>
      <admst:if test="[name='bw_not']">
        <admst:variable name="op" select="~"/>
      </admst:if>
      <admst:apply-templates select="arg1" match="af:print:expression"><admst:variable name="arg1" select="%(returned('x')/value)"/></admst:apply-templates>
      <admst:return name="x" string="($op$arg1)"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:return name="dx.%(name)" string="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:variable name="x" select="%(returned('x')/value)"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:variable name="dx_%(name)" select="%(returned('dx.%(name)')/value)"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="af:print:expression">
        <admst:variable name="y" select="%(returned('x')/value)"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:variable name="dy_%(name)" select="%(returned('dx.%(name)')/value)"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[name='addp']">
          <admst:choose>
            <admst:when test="[$x='0.0' and $y='0.0']">
              <admst:return name="x" string="0.0"/>
            </admst:when>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" string="(+$y)"/>
            </admst:when>
            <admst:when test="[$y='0.0']">
              <admst:return name="x" string="$x"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" string="($x+$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:variable name="df" select="%(name)"/>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" string="(+$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" string="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" string="($dx+$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='addm']">
          <admst:choose>
            <admst:when test="[$x='0.0' and $y='0.0']">
              <admst:return name="x" string="0.0"/>
            </admst:when>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" string="(-$y)"/>
            </admst:when>
            <admst:when test="[$y='0.0']">
              <admst:return name="x" string="$x"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" string="($x-$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:variable name="df" select="%(name)"/>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" string="(-$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" string="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" string="($dx-$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='multtime']">
          <admst:choose>
            <admst:when test="[$x='0.0' or $y='0.0']">
              <admst:return name="x" string="0.0"/>
            </admst:when>
            <admst:when test="[$x='1.0' and $y='1.0']">
              <admst:return name="x" string="1.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" string="($x*$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:variable name="df" select="%(name)"/>
            <admst:choose>
              <admst:when test="[$x='0.0' or $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:return name="dx.$df" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='1.0']">
                <admst:return name="dx.$df" string="($x)"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='0.0']">
                <admst:return name="dx.$df" string="($y)"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" string="($x*$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" string="$dx*$y"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='1.0']">
                <admst:return name="dx.$df" string="($x+$y)"/>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:return name="dx.$df" string="($y+($dy*$x))"/>
              </admst:when>
              <admst:when test="[$dy='1.0']">
                <admst:return name="dx.$df" string="($dx*$y)+$x"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:return name="dx.$df" string="$dy"/>
              </admst:when>
              <admst:when test="[$y='1.0']">
                <admst:return name="dx.$df" string="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" string="(($dx*$y)+($x*$dy))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='multdiv']">
          <admst:choose>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" string="0.0"/>
            </admst:when>
            <admst:when test="[$x='1.0' and $y='1.0']">
              <admst:return name="x" string="1.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" string="($x/$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:variable name="df" select="%(name)"/>
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$(df))"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:return name="dx.$df" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" string="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" string="(-1/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" string="(-$dy/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" string="(-$x/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" string="(-($x*$dy)/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='0.0']">
                    <admst:return name="dx.$df" string="(1/$y)"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" string="(($y-$x)/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" string="(($y-($x*$dy))/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:choose>
                  <admst:when test="[$y='1.0']">
                    <admst:return name="dx.$df" string="$dx"/>
                  </admst:when>
                  <admst:when test="[$dy='0.0']">
                    <admst:return name="dx.$df" string="$dx/$y"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" string="(($dx*$y)-$x)/($y*$y)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" string="($dx*$y-$x*$dy)/($y*$y)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[name='bw_equr']">
              <admst:return name="x" string="($x^~$y)"/>
            </admst:when>
            <admst:when test="[name='bw_equl']">
              <admst:return name="x" string="($x~^$y)"/>
            </admst:when>
            <admst:when test="[name='bw_xor']">
              <admst:return name="x" string="($x^$y)"/>
            </admst:when>
            <admst:when test="[name='bw_or']">
              <admst:return name="x" string="($x|$y)"/>
            </admst:when>
            <admst:when test="[name='bw_and']">
              <admst:return name="x" string="($x&amp;$y)"/>
            </admst:when>
            <admst:when test="[name='or']">
              <admst:return name="x" string="($x||$y)"/>
            </admst:when>
            <admst:when test="[name='and']">
              <admst:return name="x" string="($x&amp;&amp;$y)"/>
            </admst:when>
            <admst:when test="[name='equ']">
              <admst:return name="x" string="($x==$y)"/>
            </admst:when>
            <admst:when test="[name='multmod']">
              <admst:return name="x" string="((int)$x%%(int)$y)"/>
            </admst:when>
            <admst:when test="[name='notequ']">
              <admst:return name="x" string="($x!=$y)"/>
            </admst:when>
            <admst:when test="[name='lt']">
              <admst:return name="x" string="($x&lt;$y)"/>
            </admst:when>
            <admst:when test="[name='lt_equ']">
              <admst:return name="x" string="($x&lt;=$y)"/>
            </admst:when>
            <admst:when test="[name='gt']">
              <admst:return name="x" string="($x&gt;$y)"/>
            </admst:when>
            <admst:when test="[name='gt_equ']">
              <admst:return name="x" string="($x&gt;=$y)"/>
            </admst:when>
            <admst:when test="[name='shiftr']">
              <admst:return name="x" string="($x&gt;&gt;$y)"/>
            </admst:when>
            <admst:when test="[name='shiftl']">
              <admst:return name="x" string="($x&lt;&lt;$y)"/>
            </admst:when>
            <admst:otherwise>
              <admst:error format="%(name): function not handled\n"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:return name="dx.%(name)" string="0.0"/>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:variable name="x" select="%(returned('x')/value)"/>
      </admst:apply-templates>
      <admst:if test="[name='conditional']">
        <admst:apply-templates select="arg2" match="af:print:expression">
          <admst:variable name="y" select="%(returned('x')/value)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:variable name="dy_%(name)" select="%(returned('dx.%(name)')/value)"/>
          </admst:for-each>
        </admst:apply-templates>
        <admst:apply-templates select="arg3" match="af:print:expression">
          <admst:variable name="z" select="%(returned('x')/value)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:variable name="dz_%(name)" select="%(returned('dx.%(name)')/value)"/>
          </admst:for-each>
        </admst:apply-templates>
        <admst:return name="x" string="($x?$y:$z)"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:variable name="df" select="%(name)"/>
          <admst:return name="dx.$df" string="($x?$(dy_$df):$(dz_$df))"/>
        </admst:for-each>
      </admst:if>
    </admst:when>

    <admst:when test="adms[datatypename='function']">
      <admst:apply-templates select="." match="afunction:getname">
        <admst:variable name="function" select="%(returned('afunction:getname')/value)"/>
      </admst:apply-templates>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[not($args='')]">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="af:print:expression">
          <admst:variable name="index" select="%(index(../arguments,.))"/>
          <admst:variable name="args" select="$args%(returned('x')/value)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:variable name="arg$(index)_%(name)" select="%(returned('dx.%(name)')/value)"/>
          </admst:for-each>
        </admst:apply-templates>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[ name='cos' or name='sin' or name='tan' or name='cosh' or name='sinh' or name='tanh' or name='acos' or name='asin'
                            or name='atan' or name='ln' or name='log' or name='exp' or name='sqrt' or name='abs' or name='limexp'
                            or name='pow' or name='hypot' or name='min' or name='max' ]">
          <admst:return name="x" string="_$function($args)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:variable name="name" path="name"/>
            <admst:variable name="ret" select=""/>
            <admst:for-each select="../../arguments">
              <admst:if test="[not($ret='')]">
                <admst:variable name="ret" select="$ret+"/>
              </admst:if>
              <admst:variable name="index" select="%(index(../arguments,.))"/>
              <admst:variable name="ret" select="$(ret)_d$(index)_$function($args)*($(arg$(index)_$name))"/>
            </admst:for-each>
            <admst:return name="dx.$name" string="$ret"/>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='ceil' or name='floor']">
          <admst:return name="x" string="$function($args)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:variable name="name" path="name"/>
            <admst:return name="dx.$name" string="0.0"/>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:return name="x" string="$(module)_$function($args)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:variable name="name" path="name"/>
            <admst:variable name="darg" select=""/>
            <admst:for-each select="../../arguments">
              <admst:variable name="index" select="%(index(../arguments,.))"/>
              <admst:variable name="darg" select="$darg,($(arg$(index)_$name))"/>
            </admst:for-each>
            <admst:return name="dx.$name" string="$(module)_d_$function($args$darg)"/>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>

    <admst:when test="adms[datatypename='string']">
      <admst:return name="x" string="&quot;%(value)&quot;"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:return name="dx.%(name)" string="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='number']">
      <admst:choose>
        <admst:when test="[scalingunit='1']">
          <admst:return name="x" string="%(value)"/>
        </admst:when>
        <admst:when test="[scalingunit='E']">
          <admst:return name="x" string="(%(value)*1.0e+18)"/>
        </admst:when>
        <admst:when test="[scalingunit='P']">
          <admst:return name="x" string="(%(value)*1.0e+15)"/>
        </admst:when>
        <admst:when test="[scalingunit='T']">
          <admst:return name="x" string="(%(value)*1.0e+12)"/>
        </admst:when>
        <admst:when test="[scalingunit='G']">
          <admst:return name="x" string="(%(value)*1.0e+9)"/>
        </admst:when>
        <admst:when test="[scalingunit='M']">
          <admst:return name="x" string="(%(value)*1.0e+6)"/>
        </admst:when>
        <admst:when test="[scalingunit='k']">
          <admst:return name="x" string="(%(value)*1.0e+3)"/>
        </admst:when>
        <admst:when test="[scalingunit='h']">
          <admst:return name="x" string="(%(value)*1.0e+2)"/>
        </admst:when>
        <admst:when test="[scalingunit='D']">
          <admst:return name="x" string="(%(value)*1.0e+1)"/>
        </admst:when>
        <admst:when test="[scalingunit='d']">
          <admst:return name="x" string="(%(value)*1.0e-1)"/>
        </admst:when>
        <admst:when test="[scalingunit='c']">
          <admst:return name="x" string="(%(value)*1.0e-2)"/>
        </admst:when>
        <admst:when test="[scalingunit='m']">
          <admst:return name="x" string="(%(value)*1.0e-3)"/>
        </admst:when>
        <admst:when test="[scalingunit='u']">
          <admst:return name="x" string="(%(value)*1.0e-6)"/>
        </admst:when>
        <admst:when test="[scalingunit='n']">
          <admst:return name="x" string="(%(value)*1.0e-9)"/>
        </admst:when>
        <admst:when test="[scalingunit='A']">
          <admst:return name="x" string="(%(value)*1.0e-10)"/>
        </admst:when>
        <admst:when test="[scalingunit='p']">
          <admst:return name="x" string="(%(value)*1.0e-12)"/>
        </admst:when>
        <admst:when test="[scalingunit='f']">
          <admst:return name="x" string="(%(value)*1.0e-15)"/>
        </admst:when>
        <admst:when test="[scalingunit='a']">
          <admst:return name="x" string="(%(value)*1.0e-18)"/>
        </admst:when>
        <admst:otherwise>
          <admst:fatal format="scaling unit not supported: %(scalingunit)\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:return name="dx.%(name)" string="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): not handled inside expression\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- -------------------------------------------------------------------- -->
<admst:template match="af:print">
  <admst:choose>
    <admst:when test="adms[datatypename='callfunction']">
      <admst:choose>
        <admst:when test="function[name='\$strobe']">
          <admst:variable name="outputfile" select="stdout"/>
        </admst:when>
      </admst:choose>
      <admst:variable name="args" select=""/>
      <admst:for-each select="function/arguments">
        <admst:apply-templates select="." match="af:print:expression">
          <admst:variable name="index" select="%(index(../arguments,.))"/>
          <admst:variable name="args" select="$args,%(returned('x')/value)"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" string="fprintf($outputfile$args); fprintf($outputfile,&quot;\\n&quot;);\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="af:print:expression">
        <admst:variable name="whileblock" select="%(returned('x')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="while" match="af:print">
        <admst:variable name="while" select="%(returned('x')/value)"/>
      </admst:apply-templates>
      <admst:return name="x" string="while($whileblock)\n$while"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="af:print:expression">
        <admst:variable name="if" select="%(returned('x')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="then" match="af:print">
        <admst:variable name="then" select="%(returned('x')/value)"/>
        </admst:apply-templates>
      <admst:if test="else">
        <admst:apply-templates select="else" match="af:print">
          <admst:variable name="then" select="$(then)else\n%(returned('x')/value)"/>
        </admst:apply-templates>
      </admst:if>
      <admst:return name="x" string="if($if)\n$then"/>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="af:print:expression">
        <admst:variable name="case" select="switch ((int)%(returned('x')/value)) {\n"/>
      </admst:apply-templates>
      <admst:for-each select="caseitem">
        <admst:variable name="condition" select=""/>
        <admst:for-each select="condition">
          <admst:variable name="condition" select="$condition case %(.):"/>
        </admst:for-each>
        <admst:variable name="case" select="$case $condition"/>
        <admst:if test="[defaultcase='yes']">
          <admst:variable name="case" select="$case default:"/>
        </admst:if>
        <admst:variable name="case" select="$case \n"/>
        <admst:apply-templates select="code" match="af:print">
          <admst:variable name="case" select="$case%(returned('x')/value) break;\n"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" string="$case }"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:fatal format="contribution not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='assignment']">
      <admst:apply-templates select="rhs" match="af:print:expression">
        <admst:return name="x" string="%(../lhs/name)=%(returned('x')/value);\n"/>
      </admst:apply-templates>
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
      <admst:return name="x" string=";"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:variable name="block" select=""/>
      <admst:for-each select="item">
        <admst:apply-templates select="." match="af:print">
          <admst:variable name="block" select="$block%(returned('x')/value)"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" string="{$block}"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): not handled inside blocks\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>


<admst:template match="v2c:converttype">
  <admst:choose>
    <admst:when test="[type='integer']">
      <admst:text format="int"/>
    </admst:when>
    <admst:when test="[type='real']">
      <admst:text format="double"/>
    </admst:when>
    <admst:when test="[type='string']">
      <admst:text format="char*"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="should not be reached\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="analogfunctionH">
	<admst:for-each select="/module/analogfunction">
	<admst:variable name="function" select="%(name)"/>
	<admst:apply-templates select="." match="v2c:converttype"/>
	$function (
	<admst:join select="variable[input='yes']" separator=", ">
	<admst:apply-templates select="." match="v2c:converttype"/>
	<admst:text format=" %(name)"/>
	</admst:join>)
	;
	
	<admst:apply-templates select="." match="v2c:converttype"/>
	d_$(function) (
	<admst:join select="variable[input='yes']" separator=", ">
	<admst:apply-templates select="." match="v2c:converttype"/><admst:text format=" %(name)"/>
	</admst:join>, <admst:join select="variable[input='yes']" separator=", ">
	<admst:apply-templates select="." match="v2c:converttype"/><admst:text format=" d_%(name)"/>
	</admst:join>)
	;
	</admst:for-each>
</admst:template>

<admst:template match="analogfunctionC">
	<admst:for-each select="/module/analogfunction">
	<admst:variable name="globalanalogfunction" select="%(.)"/>
	<admst:variable name="function" select="%(name)"/>
	<admst:apply-templates select="." match="v2c:converttype"/> 
	$(DEV_NAME)::$function (
	<admst:join select="variable[input='yes']" separator=", ">
	<admst:apply-templates select="." match="v2c:converttype"/><admst:text format=" %(name)"/>
	</admst:join>
	)
	{
	<admst:text format="double $function; "/>
	<admst:for-each select="variable[input='no' and output='no']">
	<admst:apply-templates select="." match="v2c:converttype"/>
	<admst:text format=" %(name);"/>
	</admst:for-each>
	<admst:apply-templates select="tree" match="af:print">
	<admst:text format="%(returned('x')/value)"/>
	</admst:apply-templates>
	return $function;
	}
	double $(DEV_NAME)::d_$(function) (
	<admst:join select="variable[input='yes']" separator=", ">
	
	<admst:apply-templates select="." match="v2c:converttype"/>
	<admst:text format=" %(name)"/>
	</admst:join>
	,
	<admst:join select="variable[input='yes']" separator=", ">
	<admst:apply-templates select="." match="v2c:converttype"/>
	<admst:text format=" d_%(name)"/>
	</admst:join>
	)
	{
	<admst:text format="double $function"/>
	<admst:for-each select="$globalanalogfunction/variable[input='yes']">
	<admst:variable name="ddx" select="%(name)"/>
	<admst:text format="; double $(function)_$(ddx)"/>
	</admst:for-each>
	<admst:for-each select="variable[input='no' and output='no']">
	<admst:variable name="name" select="%(name)"/>
	<admst:text format="; "/>
	<admst:apply-templates select="." match="v2c:converttype"/>
	<admst:text format=" $(name)"/>
	<admst:for-each select="$globalanalogfunction/variable[input='yes']">
	<admst:variable name="ddx" select="%(name)"/>
	<admst:text format="; "/>
	<admst:apply-templates select="." match="v2c:converttype"/><admst:text format=" $(name)_$(ddx)"/>
	</admst:for-each>
	</admst:for-each>
	;
	<admst:apply-templates select="tree" match="af:print:derivate">
	<admst:text format="%(returned('x')/value)"/>
	</admst:apply-templates>
	return 
	<admst:join select="$globalanalogfunction/variable[input='yes']" separator="+">
	<admst:text format="$(function)_%(name)*d_%(name)"/>
	</admst:join>
	;
	}
	
	</admst:for-each>
</admst:template>

<admst:template match="af:print:derivate">
  <admst:choose>
    <admst:when test="adms[datatypename='callfunction']">
      <admst:choose>
        <admst:when test="function[name='\$strobe']">
          <admst:variable name="outputfile" select="stdout"/>
        </admst:when>
      </admst:choose>
      <admst:variable name="args" select=""/>
      <admst:for-each select="function/arguments">
        <admst:apply-templates select="." match="af:print:expression">
          <admst:variable name="index" select="%(index(../arguments,.))"/>
          <admst:variable name="args" select="$args,%(returned('x')/value)"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" string="fprintf($outputfile$args); fprintf($outputfile,&quot;\\n&quot;);\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="af:print:expression">
        <admst:variable name="whileblock" select="%(returned('x')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="while" match="af:print:derivate">
        <admst:variable name="while" select="%(returned('x')/value)"/>
      </admst:apply-templates>
      <admst:return name="x" string="while($whileblock)\n$while"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="af:print:expression">
        <admst:variable name="if" select="%(returned('x')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="then" match="af:print:derivate">
        <admst:variable name="then" select="%(returned('x')/value)"/>
        </admst:apply-templates>
      <admst:if test="else">
        <admst:apply-templates select="else" match="af:print:derivate">
          <admst:variable name="then" select="$(then)else\n%(returned('x')/value)"/>
        </admst:apply-templates>
      </admst:if>
      <admst:return name="x" string="if($if)\n$then"/>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="af:print:expression">
        <admst:variable name="case" select="switch ((int)%(returned('x')/value)) {\n"/>
      </admst:apply-templates>
      <admst:for-each select="caseitem">
        <admst:variable name="condition" select=""/>
        <admst:for-each select="condition">
          <admst:variable name="condition" select="$condition case %(.):"/>
        </admst:for-each>
        <admst:variable name="case" select="$case $condition"/>
        <admst:if test="[defaultcase='yes']">
          <admst:variable name="case" select="$case default:"/>
        </admst:if>
        <admst:variable name="case" select="$case \n"/>
        <admst:apply-templates select="code" match="af:print:derivate">
          <admst:variable name="case" select="$case%(returned('x')/value) break;\n"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" string="$case }"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:fatal format="contribution not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='assignment']">
      <admst:variable name="lhs" select="%(lhs/name)"/>
      <admst:apply-templates select="rhs" match="af:print:expression">
        <admst:variable name="rhs" select=""/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:variable name="rhs" select="$rhs$(lhs)_%(name)=%(returned('dx.%(name)')/value);\n"/>
        </admst:for-each>
        <admst:variable name="rhs" select="$rhs$lhs=%(returned('x')/value);\n"/>
      </admst:apply-templates>
      <admst:return name="x" string="{$rhs}\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
      <admst:return name="x" string=";"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:variable name="block" select=""/>
      <admst:for-each select="item">
        <admst:apply-templates select="." match="af:print:derivate">
          <admst:variable name="block" select="$block%(returned('x')/value)"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" string="{$block}"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): not handled inside blocks\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:apply-templates select="." match="function"/>

</admst>

<admst version="2.3.0">

<!-- *********************************************************************************** -->
<!-- *********************** tree traverse - guesstopology ***************************** -->
<!-- *********************************************************************************** -->

<admst:for-each select="/module">
	<admst:value-of select="attribute[name='ngspicename']/value"/>
	<admst:variable name="module" select="%s"/>
	<admst:variable name="DEV_NAME" select="DEV_%(upper-case(name))"/>
	<admst:variable name="MODEL_NAME" select="MODEL_%(upper-case(name))"/>

	<admst:open file="$(filename)_guesstopology.hxx">
		<admst:apply-templates select="analog/code[datatypename='block']/variable" match="generate_c:declare_variable"/>
		
		<admst:for-each select="analog/code[datatypename='block']/item">
		<admst:if test="[(datatypename!='block') or (datatypename='block'
		and name!='initial_model' and name!='initializeModel' and name!='initial_instance' 
		and name!='initializeInstance')]">
		<admst:apply-templates select="." match="ngspiseMODULEguesstopology.cevaluatetopology"/>
		</admst:if>
		</admst:for-each>
	</admst:open>
</admst:for-each>

<!--admst:for-each select="analog/code[datatypename='block']/item">
<admst:if test="[(datatypename!='block') or (datatypename='block'
and name!='initial_model' and name!='initializeModel' and name!='initial_instance'
and name!='initializeInstance')]">
<admst:apply-templates select="." match="evaluate.localvariables"/>
</admst:if>
</admst:for-each>
<admst:for-each select="$localvariables">
<admst:apply-templates select="" match="generate_c:declare_variable"/>
</admst:for-each-->

<!-- ----------------------------------------------------------------- -->
<admst:template match="ngspiseMODULEguesstopology.cevaluatetopology">
<admst:message test="[/dbg_xml='yes']" format="*ngspiseMODULEguesstopology.cevaluatetopology*\n"/>
  
  <admst:if test="[datatypename='block']">
	{ // begin of adms-block

	<admst:apply-templates select="variable" match="generate_c:declare_variable"/>
  </admst:if>

  <admst:choose>
    <admst:when test="[datatypename='callfunction']"/>
    <admst:when test="[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="ngspiseMODULEguesstopology.cevaluatetopology"/>
      <admst:apply-templates select="while" match="ngspiseMODULEguesstopology.cevaluatetopology"/>
    </admst:when>
    <admst:when test="[datatypename='conditional']">
      <admst:if test="if[nilled(variable[OPdependent='yes'])]">
        <admst:apply-templates select="if" match="ngspiseMODULEguesstopology.cevaluatetopology"/>
        <admst:choose>
          <admst:when test="if/math[dependency='constant']">
            <admst:apply-templates select="if/tree" match="stringify_expression"/>
            <admst:text format="if\n(%s)\n"/>
            <admst:text format="{\n"/>
		<!--admst:apply-templates select="then/variable" match="generate_c:declare_variable"/-->
            	<admst:apply-templates select="then" match="ngspiseMODULEguesstopology.cevaluatetopology"/>
            <admst:text format="}\n"/>
            <admst:if test="[exists(else)]">
              <admst:text format="else\n"/>
              <admst:text format="{\n"/>
              <admst:apply-templates select="else" match="ngspiseMODULEguesstopology.cevaluatetopology"/>
              <admst:text format="}\n"/>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:apply-templates select="then" match="ngspiseMODULEguesstopology.cevaluatetopology"/>
            <admst:apply-templates select="else" match="ngspiseMODULEguesstopology.cevaluatetopology"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='contribution']">
      <admst:if test="lhs[discipline/potential=nature]">
        <admst:choose>
          <admst:when test="lhs/branch[grounded='no']">
                                                            	
            <admst:text test="lhs/branch/nnode[location='internal']"
              format="_nodes[$node_prefix%(lhs/branch/nnode/name)] 
                      = _nodes[$node_prefix%(lhs/branch/pnode/name)]; // nnode collapsed \n"/>
			              
			<admst:text test="lhs/branch/pnode[location='internal']"
			              	format="_nodes[$node_prefix%(lhs/branch/pnode/name)] = _nodes[$node_prefix%(lhs/branch/nnode/name)]; // pnode collapsed \n"/>

          </admst:when>
          <admst:otherwise>
            <admst:text format="$node_prefix%(lhs/branch/pnode/name) = 0; /* pnode collapsed to GND */ \n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
      <admst:variable name="contribution" select="%(.)"/>
      <admst:variable name="psource" select="%(lhs/branch/pnode)"/>
      <admst:variable name="nsource" select="%(lhs/branch/nnode)"/>
      <admst:for-each select="rhs/probe">
        <admst:variable name="pprobe" select="%(branch/pnode)"/>
        <admst:variable name="nprobe" select="%(branch/nnode)"/>
        <admst:choose>
          <admst:when test="$contribution[static='yes']"> <admst:text format="  static_"/> </admst:when>
          <admst:when test="$contribution[dynamic='yes']"> <admst:text format="  dynamic_"/> </admst:when>
          <admst:when test="$contribution[whitenoise='yes']"> <admst:text format="  whitenoise_"/> </admst:when>
          <admst:when test="$contribution[flickernoise='yes']"> <admst:text format="  flickernoise_"/> </admst:when>
        </admst:choose>
        <admst:choose>
          <admst:when test="[($nprobe/grounded='no')and($nsource/grounded='no')]">
            <admst:text format="jacobian4(%($psource/name),%($nsource/name),%($pprobe/name),%($nprobe/name))\n"/>
          </admst:when>
          <admst:when test="[($nprobe/grounded='no')and($nsource/grounded='yes')]">
            <admst:text format="jacobian2p(%($psource/name),%($pprobe/name),%($nprobe/name))\n"/>
          </admst:when>
          <admst:when test="[$nsource/grounded='no']">
            <admst:text format="jacobian2s(%($psource/name),%($nsource/name),%($pprobe/name))\n"/>
          </admst:when>
          <admst:when test="[$nsource/grounded='yes']">
            <admst:text format="jacobian1(%($psource/name),%($pprobe/name))\n"/>
          </admst:when>
        </admst:choose>
      </admst:for-each>
    </admst:when>
    <admst:when test="[datatypename='assignment']">
      <!-- ****** TODO: "fixed" here ********** -->
      <!--admst:if test="[(lhs/insource='yes') and (lhs/OPdependent='no')]">
        <admst:apply-templates select="lhs" match="variable:lhs"/>
        <admst:text format="="/>
        <admst:apply-templates select="rhs/tree" match="stringify_expression"/>
        <admst:text format="%s;\n"/>
      </admst:if-->
    </admst:when>
    <admst:when test="[datatypename='block']">
      <admst:apply-templates select="item" match="ngspiseMODULEguesstopology.cevaluatetopology"/>
    </admst:when>
    <admst:when test="[datatypename='expression']"/>
    <admst:when test="[datatypename='probe']"/>
    <admst:when test="[datatypename='variable']"/>
    <admst:when test="[datatypename='mapply_unary']"/>
    <admst:when test="[datatypename='mapply_binary']"/>
    <admst:when test="[datatypename='mapply_ternary']"/>
    <admst:when test="[datatypename='function']"/>
    <admst:when test="[datatypename='number']"/>
    <admst:when test="[datatypename='string']"/>
    <admst:when test="[datatypename='nilled']"/>
    <admst:when test="[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): adms element not implemented\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:if test="[datatypename='block']">
	} // end of adms-block

  </admst:if>

</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="function">
<admst:message test="[/dbg_xml='yes']" format="*function*\n"/>
  <admst:variable name="function" select="%(name)"/>
  <admst:variable name="args" select=""/>
  <admst:for-each select="arguments">
    <admst:variable test="[$args='']" name="args" select="$args,"/>
    <admst:apply-templates select="." match="stringify_expression"/>
    <admst:variable name="args" select="$args%s"/>
  </admst:for-each>
  <admst:choose>
    <admst:when test="[name='\$simparam']">
      <admst:apply-templates select="." match="function:simparam"/>
    </admst:when>
    <admst:when test="[name='analysis']">
      <admst:apply-templates select="." match="function:analysis"/>
    </admst:when>
    <admst:when test="[name='\$given']">
      <admst:for-each select="arguments[position(.)=1]">
        <admst:if test="[datatypename!='variable']">
          <admst:error format="$given: argument is not a variable\n"/>
        </admst:if>
        <admst:if test="[input='no']">
          <admst:value-of select="name"/>
          <admst:error format="$given(%s): argument is not a parameter\n"/>
        </admst:if>
        <admst:choose>
          <admst:when test="[parametertype='model']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/tmp" value="_model->IsParamGiven(&quot;%s&quot;)"/>
          </admst:when>
          <admst:when test="[parametertype='instance']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/tmp" value="IsParamGiven(&quot;%s&quot;)"/>
          </admst:when>
          <admst:otherwise>
            <admst:error format="$given(%s): should not be reached\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="mycode" select=""/>
      <admst:if test="[exists(arguments)]">
        <admst:for-each select="arguments">
          <admst:apply-templates select="." match="stringify_expression"/>
          <admst:choose>
            <admst:when test="[$mycode='']">
              <admst:variable name="mycode" select="%s"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="mycode" select="$mycode,%s"/>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
        <admst:variable name="mycode" select="($mycode)"/>
      </admst:if>
      <admst:variable name="mycode" select="%(fname(.)/[name='fname']/value)$mycode"/>
      <admst:value-to select="/simulator/tmp" value="$mycode"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>
 
<!-- ----------------------------------------------------------------- -->
<admst:template match="evaluate.localvariables">
<admst:message test="[/dbg_xml='yes']" format="*evaluate.localvariables*\n"/>
  <admst:choose>
    <admst:when test="[datatypename='assignment']">
      <admst:if test="[(lhs/insource='yes') and (lhs/OPdependent='no')]">
        <admst:push select="lhs[scope='local']" into="$localvariables" onduplicate="ignore"/>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='block']">
      <admst:apply-templates select="item" match="evaluate.localvariables"/>
    </admst:when>
    <admst:when test="[datatypename='conditional']">
      <admst:push select="if/variable[scope='local' and OPdependent='no']"
        into="$localvariables" onduplicate="ignore"/>
      <admst:apply-templates select="then" match="evaluate.localvariables"/>
      <admst:apply-templates select="else" match="evaluate.localvariables"/>
    </admst:when>
    <admst:when test="[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="evaluate.localvariables"/>
    </admst:when>
    <admst:when test="[datatypename='case']">
      <admst:apply-templates select="caseitem/code" match="evaluate.localvariables"/>
    </admst:when>
    <admst:when test="[datatypename='contribution']"/>
    <admst:when test="[datatypename='nilled']"/>
    <admst:when test="[datatypename='callfunction']"/>
    <admst:when test="[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:error format="'%(datatypename): should not be reached\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<admst:template match="fname">
<admst:message test="[/dbg_xml='yes']" format="*fname*\n"/>
  <admst:choose>
    <admst:when test="[name='div']"><admst:return name="fname" value="_div1"/></admst:when>
    <admst:when test="[name='abs']"><admst:return name="fname" value="fabs"/></admst:when>
    <admst:when test="[name='\$shrinkl']"><admst:return name="fname" value="shrinkl"/></admst:when>
    <admst:when test="[name='\$shrinka']"><admst:return name="fname" value="shrinka"/></admst:when>
    <admst:when test="[name='log']"><admst:return name="fname" value="log10"/></admst:when>
    <admst:when test="[name='ln']"><admst:return name="fname" value="log"/></admst:when>
    <admst:when test="[name='limexp']"><admst:return name="fname" value="limexp"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:return name="fname" value="limexp"/></admst:when>
    <admst:when test="[name='\$model']"><admst:return name="fname" value="_modelname"/></admst:when>
    <admst:when test="[name='\$instance']"><admst:return name="fname" value="_instancename"/></admst:when>
    <admst:when test="[name='\$temperature']"><admst:return name="fname" value="_circuit_temp"/></admst:when>
    <admst:otherwise><admst:return name="fname" value="%(name)"/></admst:otherwise>
  </admst:choose>
</admst:template>


</admst>

<admst version="2.3.0">

<!-- *********************************************************************************** -->
<!-- *********************************** ngspiceMODULE.hxx.xml ************************* -->
<!-- *********************************************************************************** -->

<admst:for-each select="/module">
	<admst:value-of select="attribute[name='ngspicename']/value"/>
	<admst:variable name="module" select="%s"/>
	<admst:variable name="DEV_NAME" select="DEV_%(upper-case(name))"/>
	<admst:variable name="MODEL_NAME" select="MODEL_%(upper-case(name))"/>

	<admst:open file="$(filename)_tr_eval.hxx">
		<admst:apply-templates select="analog/code" match="analog:evaluate" required="yes"/>
	</admst:open>
</admst:for-each>

<!-- ----------------------------------------------------------------- -->
<!-- analog/![initializeModel|initializeInstance|initial_model|initial_instance|initial_step|noise] -->
<admst:template match="analog:evaluate">
<admst:message test="[/dbg_xml='yes']" format="*analog:evaluate*\n"/>
  // evaluate template
  <admst:if test="code">
    <admst:assert test="code/adms[datatypename='block']" format="expecting datatypename=block\n"/>
    <admst:for-each select="code/item">
      <admst:if test="adms[datatypename='block']">
        <admst:if test="[name!='initial_model' and name!='initial_instance'
           and name!='initializeModel' and name!='initializeInstance'
           and name!='initial_step']">
          <admst:apply-templates select="." match="block:local:declaration"/>
        </admst:if>
      </admst:if>
      <admst:if test="adms[datatypename!='block']">
        <admst:apply-templates select="." match="block:local:declaration"/>
      </admst:if>
    </admst:for-each>
    <admst:apply-templates select="code" match="variable:declaration"/>
    <admst:for-each select="code/item">
      <admst:choose>
        <admst:when test="adms[datatypename!='block']">
          <admst:value-of select="./adms/datatypename"/>
          <admst:apply-templates select="." match="ngspiseMODULEload%s"/>
        </admst:when>
        <admst:otherwise>
          <admst:if test="[name!='initial_model' and name!='initial_instance' 
            and name!='initializeModel' and name!='initializeInstance'
            and name!='initial_step']">
            <admst:apply-templates select="." match="block"/>
          </admst:if>
        </admst:otherwise>
      </admst:choose>
    </admst:for-each>
  </admst:if>
</admst:template>

<!-- ----------------------------------------------------------------- -->
<!-- -------------------- analog//contribution ----------------------- -->
<!-- never called ?? admst:template match="contribution:ddt">
<admst:message test="[/dbg_xml='yes']" format="*contribution:ddt*\n"/>
  <admst:choose>
    <admst:when test="[whitenoise='yes' or flickernoise='yes']">
        <admst:warning format=" not implemented.\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="." match="contribution:nonoise:ddt"/>
    </admst:otherwise>
  </admst:choose>
</admst:template-->

<!-- ----------------------------------------------------------------- -->
<!-- never called? admst:template match="contribution:nonoise:ddt">
<admst:message test="[/dbg_xml='yes']" format="*contribution:nonoise:ddt*\n"/>
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:text format="{\n"/>
    <admst:for-each select="rhs/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getCid"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="." match="ddx:function:computation"/>
  </admst:if>
  <admst:choose>
  </admst:choose>
  <admst:choose>
    <admst:when test="lhs/branch/nnode[grounded='no']">
      <admst:text format="//exec %e(rhs/tree))\n"/>
      <admst:text format=" $e\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="lhs/branch/pnode/name"/>
      <admst:text format="// exec residual1(%s,%e(rhs/tree))\n"/>
      <admst:text format="//founnde $e"/>
    </admst:otherwise>
  </admst:choose>
  <admst:for-each select="rhs/probe">
    <admst:text format="// Rhsp %(.)\n"/>

    <admst:variable name="probepnode" select="%(branch/pnode)"/>
    <admst:variable name="probennode" select="%(branch/nnode)"/>
    <admst:variable name="probepnodename" select="%($probepnode/name)"/>
    <admst:variable name="probennodename" select="%($probennode/name)"/>
    <admst:variable name="pprobe" select="%(.)"/>
    <admst:apply-templates select="../tree" match="%(adms/datatypename)"/>
    <admst:choose>
    </admst:choose>
  </admst:for-each>
</admst:template-->

<!-- ----------------------------------------------------------------- -->
<!-- -------------------- analog//contribution ------------------------ -->
<admst:template match="contribution">
<admst:message test="[/dbg_xml='yes']" format="*contribution*\n"/>
  <admst:choose>
    <admst:when test="[whitenoise='yes' or flickernoise='yes']">
      <admst:variable name="SkipFVariable" select="y"/>
        <admst:variable name="dependency" select="%(math/dependency)"/>
        <admst:if test="[whitenoise='yes']">
          <admst:if test="[$dependency='constant']">
            <admst:text format="tnoise%(index($tnoise/item,.))="/>
          </admst:if>
          <admst:if test="[$dependency!='constant']">
            <admst:text format="wnoise%(index($wnoise/item,.))="/>
          </admst:if>
          <admst:text format=" // things 2...  \n"/>
          <admst:apply-templates select="rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
          <admst:text format="$e;\n"/>
        </admst:if>
        <admst:if test="[flickernoise='yes']">
          <admst:text format="fpnoise%(index($fnoise/item,.))="/>
          <admst:apply-templates select="rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
          <admst:text format="$e;\n"/>
          <admst:text format="fenoise%(index($fnoise/item,.))="/>
          <admst:apply-templates select="rhs/tree/arguments[2]" match="%(adms/datatypename)"/>
          <admst:text format="$e;\n"/>
        </admst:if>
      <admst:variable name="SkipFVariable" select="n"/>
    </admst:when>
    <admst:otherwise>

      <admst:text select="." format=" // contrib -&gt; nonoise \n"/>
      <admst:apply-templates select="." match="contribution:nonoise"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- compute node arguments of noise routines -->
<admst:template match="noisebranch">
<admst:message test="[/dbg_xml='yes']" format="*noisebranch*\n"/>
  <admst:variable name="n1" select=""/>
  <admst:choose>
    <admst:when test="lhs[grounded='yes']">
      <admst:return name="noisebranch" value="%(lhs/branch/pnode/name),%(lhs/branch/pnode/name)"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="noisebranch" value="%(lhs/branch/pnode/name),%(lhs/branch/nnode/name)"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- compute range of variables -->
<admst:template match="variable:range:foreach">
<admst:message test="[/dbg_xml='yes']" format="*variable:range:foreach*\n"/>
  <admst:choose>
    <admst:when test="infexpr[hasspecialnumber='NO']">
      <admst:apply-templates select="infexpr/tree" match="%(adms/datatypename)"/>
      <admst:variable name="lower" select="$e"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="lower" select="-inf"/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="supexpr[hasspecialnumber='NO']">
      <admst:apply-templates select="supexpr/tree" match="%(adms/datatypename)"/>
      <admst:variable name="upper" select="$e"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="upper" select="inf"/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="[type='include']">
      <admst:variable name="rangetype" select="from"/>
    </admst:when>
    <admst:when test="[type='exclude']">
      <admst:variable name="rangetype" select="exclude"/>
    </admst:when>
  </admst:choose>
  <admst:variable name="interval" select="$lower:$upper"/>
  <admst:choose>
    <admst:when test="[infboundtype='range_bound_include' and supboundtype='range_bound_include']">
      <admst:variable name="interval" select="[$interval]"/>
    </admst:when>
    <admst:when test="[infboundtype='range_bound_include' and supboundtype='range_bound_exclude']">
      <admst:variable name="interval" select="[$interval)"/>
    </admst:when>
    <admst:when test="[infboundtype='range_bound_exclude' and supboundtype='range_bound_include']">
      <admst:variable name="interval" select="($interval]"/>
    </admst:when>
    <admst:when test="[infboundtype='range_bound_exclude' and supboundtype='range_bound_exclude']">
      <admst:variable name="interval" select="($interval)"/>
    </admst:when>
  </admst:choose>
  <admst:text format="$rangetype $interval "/>
</admst:template>
<admst:template match="variable:range">
<admst:message test="[/dbg_xml='yes']" format="*variable:range*\n"/>
  <admst:choose>
    <admst:when test="range">
      <admst:text format="        &quot;"/>
      <admst:apply-templates select="range" match="variable:range:foreach"/>
      <admst:text format="&quot;"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="        NULL"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- -------- expression//function: mapping verilog-name == C-name of function ------- -->
<admst:template match="function:getname">
<admst:message test="[/dbg_xml='yes']" format="*function:getname*\n"/>
  <admst:choose>
    <admst:when test="[name='abs']"><admst:return name="function:getname" value="abs"/></admst:when>
    <admst:when test="[name='\$shrinkl']"><admst:return name="function:getname" value="shrinkl"/></admst:when>
    <admst:when test="[name='\$shrinka']"><admst:return name="function:getname" value="shrinka"/></admst:when>
    <admst:when test="[name='log']"><admst:return name="function:getname" value="log10"/></admst:when>
    <admst:when test="[name='ln']"><admst:return name="function:getname" value="logE"/></admst:when>
    <admst:when test="[name='limexp']"><admst:return name="function:getname" value="limexp"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:return name="function:getname" value="limexp"/></admst:when>
    <admst:when test="[name='\$model']"><admst:return name="function:getname" value="_modelname"/></admst:when>
    <admst:when test="[name='\$instance']">
      <admst:return name="function:getname" value="_instancename"/>
    </admst:when>
    <admst:when test="[name='\$temperature']">
      <admst:return name="function:getname" value="_circuit_temp"/>
    </admst:when>
    <admst:when test="[name='\$nominal_temperature']">
      <admst:return name="function:getname" value="_circuit_tnom"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="name"/><admst:return name="function:getname" value="%s"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>
<!-- -------------------------------------------------------------- -->
<admst:template match="af:print:expression">
<admst:message test="[/dbg_xml='yes']" format="*af:print:expression*\n"/>
  <admst:choose>
    <admst:when test="adms[datatypename='expression']">
      <admst:apply-templates select="tree" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="expression" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dx_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:return name="x" value="$expression"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="$(dx_%s)"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='probe']">
      <admst:fatal format="probe not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='variable']">
      <admst:value-of select="name"/>
      <admst:variable name="variable" select="%s"/>
      <admst:return name="x" value="$variable"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:variable name="ddx" select="%s"/>
        <admst:choose>
          <admst:when test="[$variable='$ddx']">
            <admst:return name="dx.$ddx" value="1.0"/>
          </admst:when>
          <admst:when test="../..[input='yes']">
            <admst:return name="dx.$ddx" value="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:return name="dx.$ddx" value="$(variable)_$ddx"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_unary']">
      <admst:if test="[name='plus']">
        <admst:variable name="op" select="+"/>
      </admst:if>
      <admst:if test="[name='minus']">
        <admst:variable name="op" select="-"/>
      </admst:if>
      <admst:if test="[name='not']">
        <admst:variable name="op" select="!"/>
      </admst:if>
      <admst:if test="[name='bw_not']">
        <admst:variable name="op" select="~"/>
      </admst:if>
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/><admst:variable name="arg1" select="%s"/>
      </admst:apply-templates>
      <admst:return name="x" value="($op$arg1)"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="x" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dx_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="y" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dy_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[name='addp']">
          <admst:choose>
            <admst:when test="[$x='0.0' and $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="(+$y)"/>
            </admst:when>
            <admst:when test="[$y='0.0']">
              <admst:return name="x" value="$x"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x+$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="(+$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="($dx+$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='addm']">
          <admst:choose>
            <admst:when test="[$x='0.0' and $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="(-$y)"/>
            </admst:when>
            <admst:when test="[$y='0.0']">
              <admst:return name="x" value="$x"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x-$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="(-$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="($dx-$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='multtime']">
          <admst:choose>
            <admst:when test="[$x='0.0' or $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='1.0' and $y='1.0']">
              <admst:return name="x" value="1.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x*$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' or $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='1.0']">
                <admst:return name="dx.$df" value="($x)"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="($y)"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="($x*$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx*$y"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='1.0']">
                <admst:return name="dx.$df" value="($x+$y)"/>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:return name="dx.$df" value="($y+($dy*$x))"/>
              </admst:when>
              <admst:when test="[$dy='1.0']">
                <admst:return name="dx.$df" value="($dx*$y)+$x"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:return name="dx.$df" value="$dy"/>
              </admst:when>
              <admst:when test="[$y='1.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="(($dx*$y)+($x*$dy))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='multdiv']">
          <admst:choose>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='1.0' and $y='1.0']">
              <admst:return name="x" value="1.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x/$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$(df))"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(-1/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="(-$dy/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(-$x/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="(-($x*$dy)/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='0.0']">
                    <admst:return name="dx.$df" value="(1/$y)"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(($y-$x)/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="(($y-($x*$dy))/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:choose>
                  <admst:when test="[$y='1.0']">
                    <admst:return name="dx.$df" value="$dx"/>
                  </admst:when>
                  <admst:when test="[$dy='0.0']">
                    <admst:return name="dx.$df" value="$dx/$y"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(($dx*$y)-$x)/($y*$y)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="($dx*$y-$x*$dy)/($y*$y)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[name='bw_equr']">
              <admst:return name="x" value="($x^~$y)"/>
            </admst:when>
            <admst:when test="[name='bw_equl']">
              <admst:return name="x" value="($x~^$y)"/>
            </admst:when>
            <admst:when test="[name='bw_xor']">
              <admst:return name="x" value="($x^$y)"/>
            </admst:when>
            <admst:when test="[name='bw_or']">
              <admst:return name="x" value="($x|$y)"/>
            </admst:when>
            <admst:when test="[name='bw_and']">
              <admst:return name="x" value="($x&amp;$y)"/>
            </admst:when>
            <admst:when test="[name='or']">
              <admst:return name="x" value="($x||$y)"/>
            </admst:when>
            <admst:when test="[name='and']">
              <admst:return name="x" value="($x&amp;&amp;$y)"/>
            </admst:when>
            <admst:when test="[name='equ']">
              <admst:return name="x" value="($x==$y)"/>
            </admst:when>
            <admst:when test="[name='multmod']">
              <admst:return name="x" value="((int)$x%%(int)$y)"/>
            </admst:when>
            <admst:when test="[name='notequ']">
              <admst:return name="x" value="($x!=$y)"/>
            </admst:when>
            <admst:when test="[name='lt']">
              <admst:return name="x" value="($x&lt;$y)"/>
            </admst:when>
            <admst:when test="[name='lt_equ']">
              <admst:return name="x" value="($x&lt;=$y)"/>
            </admst:when>
            <admst:when test="[name='gt']">
              <admst:return name="x" value="($x&gt;$y)"/>
            </admst:when>
            <admst:when test="[name='gt_equ']">
              <admst:return name="x" value="($x&gt;=$y)"/>
            </admst:when>
            <admst:when test="[name='shiftr']">
              <admst:return name="x" value="($x&gt;&gt;$y)"/>
            </admst:when>
            <admst:when test="[name='shiftl']">
              <admst:return name="x" value="($x&lt;&lt;$y)"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-of select="name"/>
              <admst:error format="%s: function not handled\n"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:return name="dx.%s" value="0.0"/>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="x" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="y" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg3" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="z" select="%s"/>
      </admst:apply-templates>
      <admst:if test="[name='conditional']">
        <admst:return name="x" value="($x?$y:$z)"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="name"/>
          <admst:value-of select="name"/>
          <admst:return name="dx.%s" value="($x?$dy_%s:$dz_%s)"/>
        </admst:for-each>
      </admst:if>
    </admst:when>
    <admst:when test="adms[datatypename='function']">
      <admst:apply-templates select="." match="function:getname">
        <admst:value-of select="returned('function:getname')/value"/>
        <admst:variable name="function" select="%s"/>
      </admst:apply-templates>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[not($args='')]">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="args" select="$args%s"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:value-of select="returned('dx.%s')/value"/>
            <admst:value-of select="name"/>
            <admst:variable name="arg$(index)_%s" select="%s"/>
          </admst:for-each>
        </admst:apply-templates>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[ name='cos' or name='sin' or name='tan' or name='cosh'
                            or name='sinh' or name='tanh' or name='acos' or name='asin'
                            or name='atan' or name='ln' or name='log' or name='exp' 
                            or name='sqrt' or name='abs' or name='limexp'
                            or name='div' or name='pow' or name='hypot' or name='min' or name='max' ]">
          <admst:return name="x" value="_$function($args)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/> <admst:variable name="name" select="%s"/>
            <admst:variable name="ret" select=""/>
            <admst:for-each select="../../arguments">
              <admst:if test="[not($ret='')]">
                <admst:variable name="ret" select="$ret+"/>
              </admst:if>
              <admst:value-of select="index(../arguments,.)"/>
              <admst:variable name="index" select="%s"/>
              <admst:variable name="ret" select="$(ret)_d$(index)_$function($args)*($(arg$(index)_$name))"/>
            </admst:for-each>
            <admst:return name="dx.$name" value="$ret"/>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:return name="x" value="$function($args)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/> <admst:variable name="name" select="%s"/>
            <admst:variable name="darg" select=""/>
            <admst:for-each select="../../arguments">
              <admst:value-of select="index(../arguments,.)"/>
              <admst:variable name="index" select="%s"/>
              <admst:variable name="darg" select="$darg,($(arg$(index)_$name))"/>
            </admst:for-each>
            <admst:return name="dx.$name" value="d_$function($args$darg)"/>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='string']">
      <admst:value-of select="value"/>
      <admst:return name="x" value="&quot;%s&quot;"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='number']">
      <admst:choose>
        <admst:when test="[scalingunit='1']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="%s"/>
        </admst:when>
        <admst:when test="[scalingunit='E']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+18)"/>
        </admst:when>
        <admst:when test="[scalingunit='P']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+15)"/>
        </admst:when>
        <admst:when test="[scalingunit='T']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+12)"/>
        </admst:when>
        <admst:when test="[scalingunit='G']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+9)"/>
        </admst:when>
        <admst:when test="[scalingunit='M']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+6)"/>
        </admst:when>
        <admst:when test="[scalingunit='k']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+3)"/>
        </admst:when>
        <admst:when test="[scalingunit='h']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+2)"/>
        </admst:when>
        <admst:when test="[scalingunit='D']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+1)"/>
        </admst:when>
        <admst:when test="[scalingunit='d']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-1)"/>
        </admst:when>
        <admst:when test="[scalingunit='c']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-2)"/>
        </admst:when>
        <admst:when test="[scalingunit='m']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-3)"/>
        </admst:when>
        <admst:when test="[scalingunit='u']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-6)"/>
        </admst:when>
        <admst:when test="[scalingunit='n']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-9)"/>
        </admst:when>
        <admst:when test="[scalingunit='A']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-10)"/>
        </admst:when>
        <admst:when test="[scalingunit='p']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-12)"/>
        </admst:when>
        <admst:when test="[scalingunit='f']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-15)"/>
        </admst:when>
        <admst:when test="[scalingunit='a']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-18)"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-of select="scalingunit"/>
          <admst:fatal format="scaling unit not supported: %s\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:otherwise>
    </admst:otherwise>
  </admst:choose>
</admst:template>
<!-- ------------------------------------------------------ -->
<admst:template match="af:print:derivate">
<admst:message test="[/dbg_xml='yes']" format="*af:print:derivate*\n"/>
  <admst:choose>
    <admst:when test="adms[datatypename='callfunction']">
      <admst:choose>
        <admst:when test="function[name='\$strobe']">
          <admst:variable name="outputfile" select="stdout"/>
        </admst:when>
      </admst:choose>
      <admst:variable name="args" select=""/>
      <admst:for-each select="function/arguments">
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="args" select="$args,%s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="fprintf($outputfile$args); fprintf($outputfile,&quot;\n&quot;);\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="whileblock" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="while" match="af:print:derivate">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="while" select="%s"/>
      </admst:apply-templates>
      <admst:return name="x" value="while($whileblock)\n$while"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="if" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="then" match="af:print:derivate">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="then" select="%s"/>
        </admst:apply-templates>
      <admst:if test="else">
        <admst:apply-templates select="else" match="af:print:derivate">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="then" select="$(then)else\n%s"/>
        </admst:apply-templates>
      </admst:if>
      <admst:return name="x" value="if($if)\n$then"/>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="case" select="switch ((int)%s) {\n"/>
      </admst:apply-templates>
      <admst:for-each select="caseitem">
        <admst:variable name="condition" select=""/>
        <admst:for-each select="condition">
          <admst:value-of select="."/>
          <admst:variable name="condition" select="$condition case %s:"/>
        </admst:for-each>
        <admst:variable name="case" select="$case $condition"/>
        <admst:if test="[defaultcase='yes']">
          <admst:variable name="case" select="$case default:"/>
        </admst:if>
        <admst:variable name="case" select="$case \n"/>
        <admst:apply-templates select="code" match="af:print:derivate">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="case" select="$case%s break;\n"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="$case }"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:fatal format="contribution not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='assignment']">
      <admst:value-of select="lhs/name"/>
      <admst:variable name="lhs" select="%s"/>
      <admst:apply-templates select="rhs" match="af:print:expression">
        <admst:variable name="rhs" select=""/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="rhs" select="$rhs$(lhs)_%s=%s;\n"/>
        </admst:for-each>
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="rhs" select="$rhs$lhs=%s;\n"/>
      </admst:apply-templates>
      <admst:return name="x" value="{$rhs}\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
      <admst:return name="x" value=";"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:variable name="block" select=""/>
      <admst:for-each select="item">
        <admst:apply-templates select="." match="af:print:derivate">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="block" select="$block%s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="{$block}"/>
    </admst:when>
    <admst:otherwise>
    </admst:otherwise>
  </admst:choose>
</admst:template>
<!-- ------------------------------------------------------------ -->
<admst:template match="af:print">
<admst:message test="[/dbg_xml='yes']" format="*af:print*\n"/>
  <admst:choose>
    <admst:when test="adms[datatypename='callfunction']">
      <admst:choose>
        <admst:when test="function[name='\$strobe']">
          <admst:variable name="outputfile" select="stdout"/>
        </admst:when>
      </admst:choose>
      <admst:variable name="args" select=""/>
      <admst:for-each select="function/arguments">
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="args" select="$args,%s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="fprintf($outputfile$args); fprintf($outputfile,&quot;\n&quot;);\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="whileblock" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="while" match="af:print">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="while" select="%s"/>
      </admst:apply-templates>
      <admst:return name="x" value="while($whileblock)\n$while"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="if" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="then" match="af:print">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="then" select="%s"/>
        </admst:apply-templates>
      <admst:if test="else">
        <admst:apply-templates select="else" match="af:print">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="then" select="$(then)else\n%s"/>
        </admst:apply-templates>
      </admst:if>
      <admst:return name="x" value="if($if)\n$then"/>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="case" select="switch ((int)%s) {\n"/>
      </admst:apply-templates>
      <admst:for-each select="caseitem">
        <admst:variable name="condition" select=""/>
        <admst:for-each select="condition">
          <admst:value-of select="."/>
          <admst:variable name="condition" select="$condition case %s:"/>
        </admst:for-each>
        <admst:variable name="case" select="$case $condition"/>
        <admst:if test="[defaultcase='yes']">
          <admst:variable name="case" select="$case default:"/>
        </admst:if>
        <admst:variable name="case" select="$case \n"/>
        <admst:apply-templates select="code" match="af:print">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="case" select="$case%s break;\n"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="$case }"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:fatal format="contribution not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='assignment']">
      <admst:apply-templates select="rhs" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:value-of select="../lhs/name"/>
        <admst:return name="x" value="%s=%s;\n"/>
      </admst:apply-templates>
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
      <admst:return name="x" value=";"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:variable name="block" select=""/>
      <admst:for-each select="item">
        <admst:apply-templates select="." match="af:print">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="block" select="$block%s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="{$block}"/>
    </admst:when>
    <admst:otherwise>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
* Returns the type of a variable. The returned type
* is either int, double, or char *. This template is
* used to create the mint:instance and model data structures.
-->
<admst:template match="vtype">
<admst:message test="[/dbg_xml='yes']" format="*vtype*\n"/>
  <admst:choose>
    <admst:when test="[type='integer']">int</admst:when>
    <admst:when test="[type='real']">double</admst:when>
    <admst:when test="[type='string']">char*</admst:when>
    <admst:otherwise>
      <admst:fatal format="variable type unknown\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>
<!-- ----------------------------------------- -->
<admst:template match="bname">
<admst:message test="[/dbg_xml='yes']" format="*bname*\n"/>
  <admst:choose>
    <admst:when test="[name='bw_equr']">
      <admst:return name="bname" value="^~"/>
    </admst:when>
    <admst:when test="[name='bw_equl']">
      <admst:return name="bname" value="~^"/>
    </admst:when>
    <admst:when test="[name='bw_xor']">
      <admst:return name="bname" value="^"/>
    </admst:when>
    <admst:when test="[name='bw_or']">
      <admst:return name="bname" value="|"/>
    </admst:when>
    <admst:when test="[name='bw_and']">
      <admst:return name="bname" value="&amp;"/>
    </admst:when>
    <admst:when test="[name='or']">
      <admst:return name="bname" value="||"/>
    </admst:when>
    <admst:when test="[name='and']">
      <admst:return name="bname" value="&amp;&amp;"/>
    </admst:when>
    <admst:when test="[name='equ']">
      <admst:return name="bname" value="=="/>
    </admst:when>
    <admst:when test="[name='notequ']">
      <admst:return name="bname" value="!="/>
    </admst:when>
    <admst:when test="[name='lt']">
      <admst:return name="bname" value="&lt;"/>
    </admst:when>
    <admst:when test="[name='lt_equ']">
      <admst:return name="bname" value="&lt;="/>
    </admst:when>
    <admst:when test="[name='gt']">
      <admst:return name="bname" value="&gt;"/>
    </admst:when>
    <admst:when test="[name='gt_equ']">
      <admst:return name="bname" value="&gt;="/>
    </admst:when>
    <admst:when test="[name='shiftr']">
      <admst:return name="bname" value="&gt;&gt;"/>
    </admst:when>
    <admst:when test="[name='shiftl']">
      <admst:return name="bname" value="&lt;&lt;"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="variable type unknown\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>
<!-- expression//function: get function name -->
<admst:template match="funcname">
<admst:message test="[/dbg_xml='yes']" format="*funcname*\n"/>
  <admst:choose>
    <admst:when test="[name='abs']"><admst:return name="fname" value="fabs"/></admst:when>
    <admst:when test="[name='\$shrinkl']"><admst:return name="fname" value="shrinkl"/></admst:when>
    <admst:when test="[name='\$shrinka']"><admst:return name="fname" value="shrinka"/></admst:when>
    <admst:when test="[name='log']"><admst:return name="fname" value="log10"/></admst:when>
    <admst:when test="[name='ln']"><admst:return name="fname" value="logE"/></admst:when>
    <admst:when test="[name='limexp']"><admst:return name="fname" value="limexp"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:return name="fname" value="limexp"/></admst:when>
    <admst:otherwise><admst:return name="fname" value="%(name)"/></admst:otherwise>
  </admst:choose>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="fname">
<admst:message test="[/dbg_xml='yes']" format="*fname*\n"/>
  <admst:choose>
    <admst:when test="[name='abs']">fabs</admst:when>
    <admst:when test="[name='\$shrinkl']">shrinkl</admst:when>
    <admst:when test="[name='\$shrinka']">shrinka</admst:when>
    <admst:when test="[name='log']">log10</admst:when>
    <admst:when test="[name='ln']">logE</admst:when>
    <admst:when test="[name='limexp']">limexp</admst:when>
    <admst:when test="[name='\$limexp']">limexp</admst:when>
    <admst:otherwise>%(name)</admst:otherwise>
  </admst:choose>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="e">
<admst:message test="[/dbg_xml='yes']" format="*e*\n"/>
  <admst:apply-templates select="." match="%(adms/datatypename)">
    <admst:if test="[$finddt='no']"> $e </admst:if>
  </admst:apply-templates>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="ddx">
<admst:message test="[/dbg_xml='yes']" format="*ddx*\n"/>
  <admst:apply-templates select="." match="%(adms/datatypename)"/>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="ddxname">
<admst:message test="[/dbg_xml='yes']" format="*ddxname*\n"/>
  <admst:return name="ddxname" value="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)_%($qprobe/nature/access)%($qprobe/branch/pnode/name)_%($qprobe/branch/nnode/name)"/>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="dxname">
<admst:message test="[/dbg_xml='yes']" format="*dxname*\n"/>
  <admst:return name="dxname" value="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)"/>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="variable">
  <admst:choose>
    <admst:when test="[input='yes' and parametertype='model']">
      <admst:variable name="e" select="_model-&gt;%(name)"/>
    </admst:when>
    <admst:when test="[input='yes' and parametertype='instance']">
      <admst:variable name="e" select="_model-&gt;%(name)"/>
    </admst:when>
    <admst:when test="[input='no' and scope='global_model']">
      <admst:variable name="e" select="_model-&gt;%(name)"/>
    </admst:when>
    <admst:when test="[input='no' and scope='global_instance']">
      <admst:variable name="e" select="$(var_prefix)%(name)"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="e" select="%(name)"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" select="0.0"/>
  <admst:if test="[insource='yes']">
    <admst:if-inside select="$pprobe" list="%(probe)">
      <admst:variable name="ep" select="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)"/>
    </admst:if-inside>
  </admst:if>
  <admst:if test="$qprobe">

  <admst:variable name="eq" select="0.0"/>
  <admst:if test="[insource='yes']">
    <admst:if-inside select="$qprobe" list="%(probe)">
      <admst:variable name="eq" select="%(name)_%($qprobe/nature/access)%($qprobe/branch/pnode/name)_%($qprobe/branch/nnode/name)"/>
    </admst:if-inside>
  </admst:if>

  <admst:variable name="epq" select="0.0"/>
  <admst:if test="[insource='yes']">
    <admst:if-inside select="$pprobe" list="%(probe)">
      <admst:if-inside select="$qprobe" list="%(probe)">
        <admst:variable name="epq" select="%(ddxname(.)/[name='ddxname']/value)"/>
      </admst:if-inside>
    </admst:if-inside>
  </admst:if>
  </admst:if>
</admst:template>

<!-- -------------------------------------------------- -->
<admst:template match="probe">
<admst:message test="[/dbg_xml='yes']" format="*probe*\n"/>
  <admst:choose>
    <admst:when test="branch/nnode[grounded='no']">
      <admst:variable name="e" select="(NP(%(branch/pnode/name))-NP(%(branch/nnode/name)))"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="e" select="NP(%(branch/pnode/name))"/>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[.=$pprobe]">
      <admst:variable name="ep" select="1.0 /*pprobe*/ "/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="ep" select="0.0"/>
    </admst:otherwise>
  </admst:choose>

  <admst:if test="$qprobe">
  <admst:choose>
    <admst:when test="[.=$qprobe]">
      <admst:variable name="eq" select="1.0 /*qprobe*/ "/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="eq" select="0.0"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="epq" select="0.0"/>
  </admst:if>

</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="node">
<admst:message test="[/dbg_xml='yes']" format="*node*\n"/>
  <admst:fatal format="module node not expected here ... %(name)\n"/>

  <admst:fatal format="module node not expected here ... %(name)\n"/>
  <admst:if test="$qprobe">

  <admst:fatal format="module node not expected here ... %(name)\n"/>
  </admst:if>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="string">
<admst:message test="[/dbg_xml='yes']" format="*string*\n"/>
  <admst:variable name="e" select="&quot;%(value)&quot;"/>

  <admst:variable name="ep" select="0.0"/>
  <admst:if test="$qprobe">

  <admst:variable name="eq" select="0.0"/>

  <admst:variable name="epq" select="0.0"/>
  </admst:if>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="number">
<admst:message test="[/dbg_xml='yes']" format="*number*\n"/>
  <admst:choose>
    <admst:when test="[scalingunit='1']">
      <admst:variable name="e" select="%(value)"/>
    </admst:when>
    <admst:when test="[scalingunit='E']">
      <admst:variable name="e" select="(%(value)*1.0e+18)"/>
    </admst:when>
    <admst:when test="[scalingunit='P']">
      <admst:variable name="e" select="(%(value)*1.0e+15)"/>
    </admst:when>
    <admst:when test="[scalingunit='T']">
      <admst:variable name="e" select="(%(value)*1.0e+12)"/>
    </admst:when>
    <admst:when test="[scalingunit='G']">
      <admst:variable name="e" select="(%(value)*1.0e+9)"/>
    </admst:when>
    <admst:when test="[scalingunit='M']">
      <admst:variable name="e" select="(%(value)*1.0e+6)"/>
    </admst:when>
    <admst:when test="[scalingunit='k']">
      <admst:variable name="e" select="(%(value)*1.0e+3)"/>
    </admst:when>
    <admst:when test="[scalingunit='h']">
      <admst:variable name="e" select="(%(value)*1.0e+2)"/>
    </admst:when>
    <admst:when test="[scalingunit='D']">
      <admst:variable name="e" select="(%(value)*1.0e+1)"/>
    </admst:when>
    <admst:when test="[scalingunit='d']">
      <admst:variable name="e" select="(%(value)*1.0e-1)"/>
    </admst:when>
    <admst:when test="[scalingunit='c']">
      <admst:variable name="e" select="(%(value)*1.0e-2)"/>
    </admst:when>
    <admst:when test="[scalingunit='m']">
      <admst:variable name="e" select="(%(value)*1.0e-3)"/>
    </admst:when>
    <admst:when test="[scalingunit='u']">
      <admst:variable name="e" select="(%(value)*1.0e-6)"/>
    </admst:when>
    <admst:when test="[scalingunit='n']">
      <admst:variable name="e" select="(%(value)*1.0e-9)"/>
    </admst:when>
    <admst:when test="[scalingunit='A']">
      <admst:variable name="e" select="(%(value)*1.0e-10)"/>
    </admst:when>
    <admst:when test="[scalingunit='p']">
      <admst:variable name="e" select="(%(value)*1.0e-12)"/>
    </admst:when>
    <admst:when test="[scalingunit='f']">
      <admst:variable name="e" select="(%(value)*1.0e-15)"/>
    </admst:when>
    <admst:when test="[scalingunit='a']">
      <admst:variable name="e" select="(%(value)*1.0e-18)"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="scaling unit not supported: %(scalingunit)\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" select="0.0"/>
  <admst:if test="$qprobe">

  <admst:variable name="eq" select="0.0"/>

  <admst:variable name="epq" select="0.0"/>
  </admst:if>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="mapply_unary">
<admst:message test="[/dbg_xml='yes']" format="*mapply_unary*\n"/>
  <admst:choose>
    <admst:when test="[name='plus']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(+$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='minus']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(-$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='not']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(!$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='bw_not']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(~$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="%(name): function not handled\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[$e='0.0']">
      <admst:variable name="ep" select="0.0"/>
    </admst:when>
    <admst:when test="[$ep='0.0']">
      <admst:variable name="ep" select="0.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[name='plus']">
          <admst:variable name="ep" select="(+$ep)"/>
        </admst:when>
        <admst:when test="[name='minus']">
          <admst:variable name="ep" select="(-$ep)"/>
        </admst:when>
        <admst:when test="[name='not']">
          <admst:variable name="ep" select="(!$ep)"/>
        </admst:when>
        <admst:when test="[name='bw_not']">
          <admst:variable name="ep" select="(~$ep)"/>
        </admst:when>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="$qprobe">

  <admst:choose>
    <admst:when test="[$e='0.0']">
      <admst:variable name="eq" select="0.0"/>
    </admst:when>
    <admst:when test="[$eq='0.0']">
      <admst:variable name="eq" select="0.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[name='plus']">
          <admst:variable name="eq" select="(+$eq)"/>
        </admst:when>
        <admst:when test="[name='minus']">
          <admst:variable name="eq" select="(-$eq)"/>
        </admst:when>
        <admst:when test="[name='not']">
          <admst:variable name="eq" select="(!$eq)"/>
        </admst:when>
        <admst:when test="[name='bw_not']">
          <admst:variable name="eq" select="(~$eq)"/>
        </admst:when>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="epq" select="0.0"/>
  </admst:if>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="mapply_binary">
<admst:message test="[/dbg_xml='yes']" format="*mapply_binary*\n"/>
  <admst:apply-templates select="arg1" match="ddx"/>
  <admst:variable name="x" select="$e"/>
  <admst:variable name="xp" select="$ep"/>
  <admst:variable name="xq" select="$eq"/>
  <admst:variable name="xpq" select="$epq"/>
  <admst:apply-templates select="arg2" match="ddx"/>
  <admst:variable name="y" select="$e"/>
  <admst:variable name="yp" select="$ep"/>
  <admst:variable name="yq" select="$eq"/>
  <admst:variable name="ypq" select="$epq"/>
  <admst:choose>
    <admst:when test="[name='addp']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:variable name="e" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="(+$y)"/>
          <admst:variable name="xp" select="0.0"/>
        </admst:when>
        <admst:when test="[arg2/math/value=0.0]">
          <admst:variable name="e" select="%($x)"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x+$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='addm']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:variable name="e" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="(-$y)"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="$ep"/>
        </admst:when>
        <admst:when test="arg2/math[value=0.0]">
          <admst:variable name="e" select="$x"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x-$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multtime']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)or(arg2/math/value=0.0)]">
          <admst:variable name="e" select="0.0"/>
          <admst:variable name="x" select="0.0"/>
          <admst:variable name="y" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="e" select="1.0"/>
          <admst:variable name="x" select="0.0"/>
          <admst:variable name="y" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x*$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multdiv']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="0.0"/>
          <admst:variable name="x" select="0.0"/>
          <admst:variable name="y" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="e" select="1.0"/>
          <admst:variable name="x" select="0.0"/>
          <admst:variable name="y" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x/$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="e" select="($x%(bname(.)/[name='bname']/value)$y)"/>
    </admst:otherwise>
  </admst:choose>

    <admst:choose>
      <admst:when test="[name='addp']">
        <admst:choose>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:variable name="ep" select="$yp"/>
          </admst:when>
          <admst:when test="[$yp='0.0']">
            <admst:variable name="ep" select="$xp"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="ep" select="($xp+$yp)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='addm']">
        <admst:choose>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:variable name="ep" select="(-$yp)"/>
          </admst:when>
          <admst:when test="[$yp='0.0']">
            <admst:variable name="ep" select="$xp"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="ep" select="($xp-$yp)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:choose>
          <admst:when test="[$x='0.0' and $y='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0' and $yp='1.0']">
            <admst:variable name="ep" select="($x)"/>
          </admst:when>
          <admst:when test="[$xp='1.0' and $yp='0.0']">
            <admst:variable name="ep" select="($y)"/>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:variable name="ep" select="($x*$yp)"/>
          </admst:when>
          <admst:when test="[$yp='0.0']">
            <admst:variable name="ep" select="$xp*$y"/>
          </admst:when>
          <admst:when test="[$xp='1.0' and $yp='1.0']">
            <admst:variable name="ep" select="($x+$y)"/>
          </admst:when>
          <admst:when test="[$xp='1.0']">
            <admst:variable name="ep" select="($y+($yp*$x))"/>
          </admst:when>
          <admst:when test="[$yp='1.0']">
            <admst:variable name="ep" select="(($xp*$y)+$x)"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:variable name="ep" select="($yp)"/>
          </admst:when>
          <admst:when test="[$y='1.0']">
            <admst:variable name="ep" select="( $xp)"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="ep" select="(($xp*$y)+($x*$yp))"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:choose>
          <admst:when test="[$x='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:choose>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(-1/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(-$yp/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:choose>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(-$x/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(-$x*$yp/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xp='1.0']">
            <admst:choose>
              <admst:when test="[$yp='0.0']">
                <admst:variable name="ep" select="(1/$y)"/>
              </admst:when>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(($y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(($y-($x*$yp))/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="[$y='1.0']">
                <admst:variable name="ep" select="( $xp )"/>
              </admst:when>
              <admst:when test="[$yp='0.0']">
                <admst:variable name="ep" select="($xp/$y)"/>
              </admst:when>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(($xp*$y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(($xp*$y-$x*$yp)/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="ep" select="0.0"/>
      </admst:otherwise>
    </admst:choose>
  <admst:if test="$qprobe">

    <admst:choose>
      <admst:when test="[name='addp']">
        <admst:choose>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:variable name="eq" select="$yq"/>
          </admst:when>
          <admst:when test="[$yq='0.0']">
            <admst:variable name="eq" select="$xq"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="($xq+$yq)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='addm']">
        <admst:choose>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:variable name="eq" select="(-$yq)"/>
          </admst:when>
          <admst:when test="[$yq='0.0']">
            <admst:variable name="eq" select="$xq"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="($xq-$yq)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:choose>
          <admst:when test="[$x='0.0' and $y='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0' and $yq='1.0']">
            <admst:variable name="eq" select="($x)"/>
          </admst:when>
          <admst:when test="[$xq='1.0' and $yq='0.0']">
            <admst:variable name="eq" select="($y)"/>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:variable name="eq" select="($x*$yq)"/>
          </admst:when>
          <admst:when test="[$yq='0.0']">
            <admst:variable name="eq" select="$xq*$y"/>
          </admst:when>
          <admst:when test="[$xq='1.0' and $yq='1.0']">
            <admst:variable name="eq" select="($x+$y)"/>
          </admst:when>
          <admst:when test="[$xq='1.0']">
            <admst:variable name="eq" select="($y+($yq*$x))"/>
          </admst:when>
          <admst:when test="[$yq='1.0']">
            <admst:variable name="eq" select="(($xq*$y)+$x)"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:variable name="eq" select="$yq"/>
          </admst:when>
          <admst:when test="[$y='1.0']">
            <admst:variable name="eq" select="$xq"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="(($xq*$y)+($x*$yq))"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:choose>
          <admst:when test="[$x='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:choose>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(-1/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(-$yq/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:choose>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(-$x/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(-$x*$yq/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xq='1.0']">
            <admst:choose>
              <admst:when test="[$yq='0.0']">
                <admst:variable name="eq" select="(1/$y)"/>
              </admst:when>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(($y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(($y-($x*$yq))/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="[$y='1.0']">
                <admst:variable name="eq" select="$xq"/>
              </admst:when>
              <admst:when test="[$yq='0.0']">
                <admst:variable name="eq" select="($xq/$y)"/>
              </admst:when>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(($xq*$y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(($xq*$y-$x*$yq)/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="eq" select="0.0"/>
      </admst:otherwise>
    </admst:choose>

    <admst:choose>
      <admst:when test="[name='addp']">
          <admst:variable name="t1" select="+$xpq"/>
          <admst:variable name="t2" select="+$ypq"/>
          <admst:variable name="epq" select="$t1$t2"/>
          <admst:choose>
            <admst:when test="[$epq='']">
              <admst:variable name="epq" select="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="epq" select="($epq)"/>
            </admst:otherwise>
          </admst:choose>
      </admst:when>
      <admst:when test="[name='addm']">
          <admst:variable name="t1" select="+$xpq"/>
          <admst:variable name="t2" select="-$ypq"/>
          <admst:variable name="epq" select="$t1$t2"/>
          <admst:choose>
            <admst:when test="[$epq='']">
              <admst:variable name="epq" select="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="epq" select="($epq)"/>
            </admst:otherwise>
          </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
          <admst:variable name="t1" select="+$xpq*$y"/>
          <admst:variable name="t2" select="+$xp*$yq"/>
          <admst:variable name="t3" select="+$xq*$yp"/>
          <admst:variable name="t4" select="+$x*$ypq"/>
          <admst:variable name="epq" select="$t1$t2$t3$t4"/>
          <admst:choose>
            <admst:when test="[$eq='']">
              <admst:variable name="eq" select="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="eq" select="($eq)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:choose>
            <admst:when test="[$epq='']">
              <admst:variable name="epq" select="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="epq" select="($epq)"/>
            </admst:otherwise>
          </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:variable name="epq" select="($xpq/$y-($xp*$yq+$xq*$yp+$x*$ypq)/$y/$y+2*$x*$yp*$yq/$y/$y/$y)"/>
      </admst:when>
    </admst:choose>
  </admst:if>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="mapply_ternary">
<admst:message test="[/dbg_xml='yes']" format="*mapply_ternary*\n"/>
  <admst:apply-templates select="arg1" match="ddx"/>
  <admst:variable name="x" select="$e"/>
  <admst:apply-templates select="arg2" match="ddx"/>
  <admst:variable name="y" select="$e"/>
  <admst:variable name="yp" select="$ep"/>
  <admst:variable name="yq" select="$eq"/>
  <admst:apply-templates select="arg3" match="ddx"/>
  <admst:variable name="z" select="$e"/>
  <admst:variable name="zp" select="$ep"/>
  <admst:variable name="zq" select="$eq"/>
  <admst:variable name="e" select="($x?$y:$z)"/>

  <admst:variable name="ep" select="($x?$yp:$zp)"/>
  <admst:if test="$qprobe">

  <admst:variable name="ep" select="($x?$yp:$zp)"/>

  <admst:variable name="epq" select="fixme"/>
  </admst:if>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="DDT">
<admst:message test="[/dbg_xml='yes']" format="*DDT*\n"/>

  <admst:if test="[$finddt='yes']">
  <!--
    <admst:text test="[$ddt_cur!='0']" format=","/> -->

    <admst:text format="ddt_$ddt_cur // $(ddt_type)%(.) \n"/>
    <!--    <admst:variable name="ddt_cur" select="%($(ddt_cur)+1)"/> -->
  </admst:if>
      <admst:variable name="ddt_cur" select="$(ddt_cur)_"/> 

</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="function">
<admst:message test="[/dbg_xml='yes']" format="*function*\n"/>
  <admst:variable name="finddthere" select="$finddt"/>
  <admst:choose>
    <admst:when test="[name='absdelay']">
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="$e"/>
    </admst:when>
    <admst:when test="[name='ddt']">


      <!-- --------------i
      <admst:text  format="//before  DDT: ep $ep\n"/>
      <admst:variable name="xp"/>
      <admst:apply-templates select="." match="DDT"/> ------ -->

      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" select="$e"/>
      <admst:variable name="xp" select="$ep"/>
      <admst:variable name="xq" select="$eq"/>
      <admst:variable name="xpq" select="$epq"/>
      <admst:variable test="[$finddt='no']" name="e" 
		select="_DDT($x, _ddt_%(adms/id(.)) ) "/>
      <admst:variable test="[$finddt='yes']" name="e" select="// DDTFOUND, $x"/>
      <admst:variable test="[$finddt='yes']" name="e" select="$e\n$(state_prefix)$(ddt_cur), "/>

      <!-- <admst:apply-templates select="." match="DDT"/>  -->

      <admst:variable name="ddt_cur" select="$(ddt_cur)_"/> 


      <!-- ------------------------ -->

    </admst:when>
    <admst:when test="[name='\$given']">
      <admst:variable name="arg1" select="%(arguments[1])"/>
      <admst:assert test="$arg1/adms[datatypename='variable']" format="\$given: argument is not a variable\n"/>
      <admst:assert test="$arg1/[input='yes']" format="\$given(%(name)): argument is not a parameter\n"/>
      <admst:choose>
        <admst:when test="$arg1/[parametertype='model']">
          <admst:variable name="e" select="_mpg(%(name),%(name)Given)"/>
        </admst:when>
        <admst:when test="$arg1/[parametertype='instance']">
          <admst:variable name="e" select="_ipg(%(name),%(name)Given)"/>
        </admst:when>
        <admst:otherwise>
          <admst:fatal format="$given(): should not be reached\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='\$temperature']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="(_circuit_tnom)"/>
    </admst:when>
    <admst:when test="[name='\$mfactor']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="MFACTOR"/>
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="e" select="(BOLTZMANN*(_circuit_tnom)/ELECTRON_CHARGE)"/>   
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="x" select="$e"/>
          <admst:variable name="xp" select="$ep"/>
          <admst:variable name="xq" select="$eq"/>
          <admst:variable name="xpq" select="$epq"/>
          <admst:variable name="e" select="(BOLTZMANN*$x/ELECTRON_CHARGE)"/>   
        </admst:when>
      </admst:choose>
    </admst:when>   
    <admst:when test="[name='\$scale']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="_scale"/>
    </admst:when>
    <admst:when test="[name='\$abstime']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="_abstime"/>
    </admst:when>
    <admst:when test="[name='ddx']">
      <admst:assert test="arguments[count(.)=2]" format="%(name): should have two arguments exactly\n"/>
      <admst:assert test="arguments[2]/adms[datatypename='probe']" format="%(name): second argument is not a probe\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="0.0 /*ddx should be top node of expression!*/"/>
    </admst:when>
    <admst:when test="[name='floor']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="floor($e)"/>
    </admst:when>
    <admst:when test="[name='ceil']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="ceil($e)"/>
    </admst:when>
    <admst:when test="[$SkipFVariable='y']">
      <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="e" select="$(fname)($args)"/>
    </admst:when>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan'
                    or name='cos' or name='cosh' or name='exp' or name='hypot'
                    or name='limexp' or name='ln' or name='log' or name='sin'
                    or name='sinh' or name='sqrt' or name='tan' or name='tanh']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:variable name="index" select="%(index(subexpression/expression/function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" select="$e"/>
      <admst:variable name="xp" select="$ep"/>
      <admst:variable name="xq" select="$eq"/>
      <admst:variable name="xpq" select="$epq"/>
      <admst:variable name="e" select="d00_$(fname)$index"/>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:assert test="arguments[count(.)=2]" format="%(name): should have two argument exactly\n"/>
      <admst:variable name="index" select="%(index(./subexpression/expression/function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" select="$e"/>
      <admst:variable name="xp" select="$ep"/>
      <admst:variable name="xq" select="$eq"/>
      <admst:variable name="xpq" select="$epq"/>
      <admst:apply-templates select="arguments[2]" match="ddx"/>
      <admst:variable name="y" select="$e"/>
      <admst:variable name="yp" select="$ep"/>
      <admst:variable name="yq" select="$eq"/>
      <admst:variable name="ypq" select="$epq"/>
      <admst:variable name="e" select="d00_$(fname)$index"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="dargs" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$dargs!='']">
          <admst:variable name="dargs" select="$dargs,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="dargs" select="$dargs$ep"/>
      </admst:for-each>
      <admst:variable name="e" select="$(fname)($args)"/>
    </admst:otherwise>
  </admst:choose>

  <!--  ???? ----- -->
  <admst:variable name="ep" select="0.0"/>
  <admst:choose>
    <admst:when test="[name='absdelay']">
    </admst:when>
    <admst:when test="[name='\$given']">
    </admst:when>
    <admst:when test="[name='\$temperature']">
    </admst:when>
    <admst:when test="[name='\$mfactor']">
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="ep" select="0.0"/>
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:variable name="ep" select="(BOLTZMANN*$xp/ELECTRON_CHARGE)"/>   
        </admst:when>
      </admst:choose>
    </admst:when>   
    <admst:when test="[name='\$scale']">
    </admst:when>
    <admst:when test="[name='\$abstime']">
    </admst:when>
    <admst:when test="[name='ddx']">
    </admst:when>
    <admst:when test="[name='floor']">
    </admst:when>
    <admst:when test="[name='ceil']">
    </admst:when>
    <admst:when test="[$SkipFVariable='y']">
    </admst:when>
    <admst:when test="[name='ddt']">
      <admst:variable name="ep" select="$xp"/> <!-- ??? -->
    </admst:when>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' 
                    or name='cos' or name='cosh' or name='exp' or name='hypot'
                    or name='limexp' or name='ln' or name='log' or name='sin'
                    or name='sinh' or name='sqrt' or name='tan' or name='tanh']">
      <admst:variable name="index" select="%(index(subexpression/expression/function,.))"/>
      <admst:choose>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="ep" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="$xp*d10_$(fname)$index"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:variable name="index" select="%(index(./subexpression/expression/function,.))"/>
      <admst:choose>
        <admst:when test="[$xp='0.0' and $yp='0.0']">
          <admst:variable name="ep" select="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="ep" select="(d11_$(fname)$index*$yp)"/>
        </admst:when>
        <admst:when test="[$yp='0.0']">
          <admst:variable name="ep" select="(d10_$(fname)$index*$xp)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="(d10_$(fname)$index*$xp+d11_$(fname)$index*$yp)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="ep" select="d_$(fname)($args,$dargs)"/>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="$qprobe">

  <admst:variable name="eq" select="0.0"/>
  <admst:choose>
    <admst:when test="[name='absdelay']">
    </admst:when>
    <admst:when test="[name='\$given']">
    </admst:when>
    <admst:when test="[name='\$temperature']">
    </admst:when>
    <admst:when test="[name='\$mfactor']">
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="eq" select="0.0"/>
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:variable name="eq" select="(BOLTZMANN*$xq/ELECTRON_CHARGE)"/>   
        </admst:when>
      </admst:choose>
    </admst:when>   
    <admst:when test="[name='\$scale']">
    </admst:when>
    <admst:when test="[name='\$abstime']">
    </admst:when>
    <admst:when test="[name='ddx']">
    </admst:when>
    <admst:when test="[name='floor']">
    </admst:when>
    <admst:when test="[name='ceil']">
    </admst:when>
    <admst:when test="[$SkipFVariable='y']">
    </admst:when>
    <admst:when test="[name='ddt']">
      <admst:variable name="eq" select="$xq"/>
    </admst:when>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan'
                       or name='cos' or name='cosh' or name='exp' or name='hypot' 
                       or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' 
                       or name='sqrt' or name='tan' or name='tanh']">
      <admst:variable name="index" select="%(index(subexpression/expression/function,.))"/>
      <admst:choose>
        <admst:when test="[$xq='0.0']">
          <admst:variable name="eq" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="eq" select="$xq*d10_$(fname)$index"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:variable name="index" select="%(index(./subexpression/expression/function,.))"/>
      <admst:choose>
        <admst:when test="[$xq='0.0' and $yq='0.0']">
          <admst:variable name="eq" select="0.0"/>
        </admst:when>
        <admst:when test="[$xq='0.0']">
          <admst:variable name="eq" select="(d11_$(fname)$index*$yq)"/>
        </admst:when>
        <admst:when test="[$yq='0.0']">
          <admst:variable name="eq" select="(d10_$(fname)$index*$xq)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="eq" select="(d10_$(fname)$index*$xq+d11_$(fname)$index*$yq)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="eq" select="d_$(fname)($args,$dargs)"/>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan'
                       or name='cos' or name='cosh' or name='exp' or name='hypot'
                       or name='limexp' or name='ln' or name='log' or name='sin'
                       or name='sinh' or name='sqrt' or name='tan' or name='tanh']">
      <admst:variable name="index" select="%(index(./subexpression/expression/function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
      <admst:choose>
        <admst:when test="[$x='0.0']">
          <admst:variable name="epq" select="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="epq" select="0.0"/>
        </admst:when>
        <admst:when test="[$xq='0.0']">
          <admst:variable name="epq" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="epq" select="(m20_$(fname)($x)*$xq*$xp+d10_$(fname)$index*$xpq)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:variable name="epq" select="fixme"/>
      <admst:if test="[$requiredderivateforddx='yes']">
        <admst:warning format="%(name): ddx dependency not implemented\n"/>
      </admst:if>
    </admst:when>
  </admst:choose>
  </admst:if>
</admst:template>

<!-- ------------------ analog//block -------------------- -->
<admst:template match="block">
<admst:message test="[/dbg_xml='yes']" format="*block*\n"/>
  <admst:text format="{ //block \n"/>
  <admst:apply-templates select="item" match="%(adms/datatypename)"/>
  <admst:text format="} //blovk \n"/>
</admst:template>
<!-- --------------------- analog//blockvariable ------------ -->
<admst:template match="blockvariable">
<admst:message test="[/dbg_xml='yes']" format="*blockvariable*\n"/>
  <admst:text format="// { //blockvariable \n"/>
  <admst:text select="variable" format="%(vtype(.)) %(name);\n"/>
  <admst:if test="variable[insource='yes']/probe">

    <admst:for-each select="variable">
      <admst:variable name="myvariable" select="%(.)"/>
      <admst:for-each select="probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:variable name="ddxinsidethisprobe" select="no"/>
          <admst:if test="$myvariable/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
            <admst:variable name="ddxinsidethisprobe" select="yes"/>
			</admst:if>

    <admst:if test="[($ddxinsidederivate='yes' and $_DERIVATEFORDDX='yes'  ) 
		 or ($ddxinsidederivate='no'  and $_DERIVATE='yes' )]">
			 <admst:text format="double %($myvariable/name)_%(nature/access)%(branch/pnode/name)_%(branch/nnode/name);\n"/>
		 </admst:if>

      </admst:for-each>
    </admst:for-each>

    <admst:for-each select="variable">
      <admst:variable name="myvariable" select="%(.)"/>
      <admst:new datatype="list" arguments="list of ddx probes">
        <admst:variable name="ddxprobes" select="%(.)"/>
        <admst:for-each select="$myvariable/probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:push into="$ddxprobes/item"
            select="$myvariable/ddxprobe/branch/pnode[.=$pprobe/branch/pnode 
                                     or .=$pprobe/branch/nnode]/$pprobe" onduplicate="ignore"/>
        </admst:for-each>
      </admst:new>
      <admst:text test="$ddxprobes/item" format="#if defined(_DERIVATE) // FIXME C\n"/>
      <admst:for-each select="$ddxprobes/item">
        <admst:variable name="pprobe" select="%(.)"/>
        <admst:for-each select="$myvariable/probe">
          <admst:variable name="qprobe" select="%(.)"/>
          <admst:text format="  double %(ddxname($myvariable)/[name='ddxname']/value);\n"/>
        </admst:for-each>
      </admst:for-each>
      <admst:text test="$ddxprobes/item" format="#endif\n"/>
    </admst:for-each>
 </admst:if>

 // } // lockvariable  FIXME \n

</admst:template>

<!-- ------ analog//function: ddx handling ---- -->
<admst:template match="function:precomputationyes">
<admst:message test="[/dbg_xml='yes']" format="*function:precomputationyes*\n"/>
  <admst:text format="//precq\n"/>
  <admst:variable name="index" select="%(index(../function,.))"/>
  <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
  //precompyes
  %(e(.))
</admst:template>

<admst:template match="function:precomputationno">
<admst:message test="[/dbg_xml='yes']" format="*function:precomputationno*\n"/>
    <admst:apply-templates select="." match="function:precomputation"/>
</admst:template>

<admst:template match="function:precomputation">
<admst:message test="[/dbg_xml='yes']" format="*function:precomputation*\n"/>
  <admst:text format="//prec $finddt\n"/>
  <admst:variable name="index" select="%(index(../function,.))"/>
  <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
  <admst:choose>
    <admst:when test="[name='add']">
      <admst:text format="m00_add(d00_add$index"/>
    </admst:when>
    <admst:when test="[name='div']">
      <admst:text format="m00_div(d00_div$index,d10_$(fname)$index"/>
    </admst:when>
    <admst:when test="[name='mult']">
      <admst:text format="m00_mult(d00_mult$index,d10_mult$index,d11_mult$index"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="double m00_$(fname)(d00_$(fname)$index"/>
    </admst:otherwise>
  </admst:choose>
  <admst:text select="arguments" format=",%(e(.))"/>
  <admst:text format=")\n"/>
</admst:template>
<!-- ------ analog//function: ddx handling ---- -->
<admst:template match="function:derivate:precomputationyes">
<admst:message test="[/dbg_xml='yes']" format="*function:derivate:precomputationyes*\n"/>
  <admst:if test="[hasVoltageDependentFunction='yes']">
    <admst:if test="[($ddxinsidederivate='yes' and $_DERIVATEFORDDX='yes'  ) 
                  or ($ddxinsidederivate='no'  and $_DERIVATE='yes' )]">
      <admst:for-each select="function">
        <admst:variable name="index" select="%(index(../function,.))"/>
        <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
        <admst:choose>
          <admst:when test="[name='exp']">
          </admst:when>
          <admst:when test="[name='add']">
          </admst:when>
          <admst:when test="[name='mult']"/>
          <admst:when test="[name='add']"/>
          <admst:when test="[name='div']">
            <admst:for-each select="arguments">
              <admst:variable name="position" select="%(position(.)-1)"/>
              <admst:if test="math[dependency!='constant']">
                <admst:text select="../arguments" format="%(e(.))"/>
              </admst:if>
            </admst:for-each>
          </admst:when>
          <admst:otherwise>
            <admst:for-each select="arguments">
              <admst:variable name="position" select="%(position(.)-1)"/>
              <admst:if test="math[dependency!='constant']">
                <admst:text select="../arguments" format="%(e(.))"/>
              </admst:if>
            </admst:for-each>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
    </admst:if>
  </admst:if>
</admst:template>
<!-- ------------ -->
<admst:template match="function:derivate:precomputationno">
<admst:message test="[/dbg_xml='yes']" format="*function:derivate:precomputationno*\n"/>
    <admst:apply-templates select="." match="function:derivate:precomputation"/>
</admst:template>
<!-- ------------ -->
<admst:template match="function:derivate:precomputation">
<admst:message test="[/dbg_xml='yes']" format="*function:derivate:precomputation*\n"/>
  <admst:if test="[hasVoltageDependentFunction='yes']">
    <!--  <admst:choose>
      <admst:when test="[$ddxinsidederivate='yes']">
        <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
      </admst:when>
      <admst:otherwise>
			<admst:text format="#if defined(_DERIVATE) // BLA\n"/>
      </admst:otherwise>
    </admst:choose> FIXME -->
    <admst:if test="[($ddxinsidederivate='yes' and $_DERIVATEFORDDX='yes'  ) 
                  or ($ddxinsidederivate='no'  and $_DERIVATE='yes' )]">
      <admst:for-each select="function">
        <admst:variable name="index" select="%(index(../function,.))"/>
        <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
        <admst:choose>
          <admst:when test="[name='exp']">
            <admst:if test="arguments/math[dependency!='constant']">
              <admst:text format="#define d10_exp$index d00_exp$index\n"/>
            </admst:if>
          </admst:when>
          <admst:when test="[name='add']">
            <admst:if test="arguments/math[dependency!='constant']">
              <admst:text format="#define d10_add$index 1\n"/>
              <admst:text format="#define d11_add$index 1\n"/>
            </admst:if>
          </admst:when>
          <admst:when test="[name='mult']"/>
          <admst:when test="[name='add']"/>
          <admst:when test="[name='div']">
            <admst:for-each select="arguments">
              <admst:variable name="position" select="%(position(.)-1)"/>
              <admst:if test="math[dependency!='constant']">
                <admst:text 
                  format="m1$(position)_$(fname)(d1$(position)_$(fname)$index,d00_$(fname)$index,d10_$(fname)$index"/>
                <admst:text select="../arguments" format=",%(e(.))"/>
                <admst:text format=")\n"/>
              </admst:if>
            </admst:for-each>
          </admst:when>
          <admst:otherwise>
            <admst:for-each select="arguments">
              <admst:variable name="position" select="%(position(.)-1)"/>
              <admst:if test="math[dependency!='constant']">
                <admst:text format="double m1%(position(.)-1)_$(fname)(d1%(position(.)-1)_$(fname)$index,d00_$(fname)$index"/>
                <admst:text select="../arguments" format=",%(e(.))"/>
                <admst:text format=")\n"/>
              </admst:if>
            </admst:for-each>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
    </admst:if>
  </admst:if>
</admst:template>
<!-- ------------------ analog//assignment:ddt ------------------------ -->
<admst:template match="assignment:ddt">
<admst:message test="[/dbg_xml='yes']" format="*assignment:ddt*\n"/>

</admst:template>
<!-- ---------------------------------------------------------- -->
<admst:template match="assignment">
<admst:message test="[/dbg_xml='yes']" format="*X3assignment*\n"/>
  <admst:variable name="assignment" select="%(.)"/>
  <admst:variable name="rhs" select="%(rhs)"/>
  <admst:variable name="lhs" select="%(lhs)"/>
  <!--  <admst:text test="[dynamic='yes']" format="#if defined(_DYNAMIC)\n"/> -->
  <admst:if   test="[dynamic='no' or $_DYNAMIC='yes']" >
    <admst:if test="[$finddt='no']">
      <admst:text test="rhs/function" format="{ // rhs function \n"/>
    </admst:if>
    <admst:for-each select="lhs/probe">
      <admst:variable name="pprobe" select="%(.)"/>
      <admst:if test="$lhs/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
        <admst:variable name="ddxinsidederivate" select="yes"/>
      </admst:if>
    </admst:for-each>
    <admst:text format="// rhsf %(rhs/function) $finddt\n"/>
    <admst:apply-templates select="rhs/function" match="function:precomputation$(finddt)"/>
    <admst:text format="/// rhsf %(rhs/function)\n"/>
    <admst:if test="lhs[insource='yes']">
      <admst:text format="// fixme: dprec %(rhs[not(nilled(function))])\n"/>
      <admst:apply-templates select="rhs[not(nilled(function))]" match="function:derivate:precomputation$(finddt)"/>
    </admst:if>
    <admst:choose>
      <admst:when test="rhs/tree/adms[datatypename='function']/..[name='ddx']">
        <!-- <admst:text format="#if defined(_DDX)\n"/>-->
        <admst:if test="[$_DDX='yes']">
          <admst:variable name="ddxprobe" select="%(rhs/tree/arguments[2])"/>
          <!-- <admst:text test="lhs[insource='yes']/probe" format="#if defined(_DERIVATE)\n"/> -->
          <admst:if test="[$_DERIVATE='yes']"> 
            <admst:for-each select="lhs[insource='yes']/probe">
              <admst:variable name="qprobe" select="%(.)"/>
              <admst:variable name="allepq"/>
              <admst:for-each select="$lhs/probe">
                <admst:variable name="pprobe" select="%(.)"/>
                <admst:choose>
                  <admst:when test="$pprobe/branch/pnode[.=$ddxprobe/branch/pnode]">
                    <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
                    <admst:variable name="allepq" select="$allepq+($epq)"/>
                  </admst:when>
                  <admst:when test="$pprobe/branch/nnode/[.=$ddxprobe/branch/pnode]">
                    <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
                    <admst:variable name="allepq" select="$allepq-($epq)"/>
                  </admst:when>
                </admst:choose>
              </admst:for-each>
              <admst:variable name="pprobe" select="%($qprobe)"/>
              <admst:if test="[$requiredderivateforddx='yes']">
                <admst:text format="// rdddx\n%(dxname($lhs)/[name='dxname']/value)=$allepq;\n"/>
              </admst:if>
            </admst:for-each>
          </admst:if>
        </admst:if> <!-- _DERIVATE -->
        <!--   <admst:text test="lhs[insource='yes']/probe" format="#endif //DERIVATE \n"/> -->
        <admst:variable name="allep"/>
        <admst:variable name="qprobe"/>
        <admst:for-each select="$lhs/probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:choose>
            <admst:when test="$pprobe/branch/pnode[.=$ddxprobe/branch/pnode]">
              <admst:text format="// rns? %(adms/datatypename)"/>
              <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
              <admst:variable name="allep" select="$allep+($ep)"/>
            </admst:when>
            <admst:when test="$pprobe/branch/nnode/[.=$ddxprobe/branch/pnode]">
              <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
              <admst:variable name="allep" select="$allep-($ep)"/>
            </admst:when>
          </admst:choose>
        </admst:for-each>
        <admst:text test="[$finddt='no']" format="%(lhs/name) = $allep; //allep\n"/>
        <admst:text test="[$finddt='no']" format="EXIT_IF_ISNAN(%(lhs/name))\n"/>
        <!-- <admst:text format="#endif // _DDX\n"/> -->
      </admst:when>
      <admst:otherwise>
        <admst:if test="lhs[insource='yes']">
          <admst:variable name="definedrequired" select="yes"/>
          <admst:variable name="ddxreq" select="no"/>
          <admst:variable name="derreq" select="no"/>
          <admst:choose>
            <admst:when test="[$ddxinsidederivate='yes']">
              <!--   <admst:text format="#if defined(_DERIVATEFORDDX) \n // probe=%($lhs/probe) ddxprobe=%($lhs/ddxprobe) \n"/> -->
              <admst:variable name="ddxreq" select="yes"/>
            </admst:when>
            <admst:when test="lhs/probe">
              <!--     <admst:text format="#if defined(_DERIVATE) // FIXME E // probe=%($lhs/probe)  ddxprobe=%($lhs/ddxprobe) \n"/> -->
              <admst:variable name="dderreq" select="yes"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="definedrequired" select="no"/>
            </admst:otherwise>
          </admst:choose>

          <admst:if test="[$ddxreq='no' or $_DERIVATEFORDDX='yes' or (( $derreq='no' or $_DERIVATE='yes') and $ddxreq='no' )] " >
            <admst:for-each select="lhs/probe">
              <admst:variable name="pprobe" select="%(.)"/>
              <admst:variable name="ddxinsidethisprobe" select="no"/>
              <admst:if test="$lhs/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
                <admst:variable name="ddxinsidethisprobe" select="yes"/>
              </admst:if>
              <admst:variable name="isinside" select="0"/>
              <admst:if test="$rhs/probe[.=$pprobe]">
                <admst:variable name="isinside" select="1"/>
              </admst:if>
              <admst:variable name="qprobe"/>
              <admst:variable name="ep" select="0.0"/>
              <admst:apply-templates select="[$isinside='1']/$rhs/tree" match="%(adms/datatypename)"/>
              <!-- <admst:text test="[$ddxinsidederivate='yes' and $ddxinsidethisprobe='no']"
                   format="#if defined(_DERIVATE) // FIXME 8\n"/> -->
              <admst:if  test="[$ddxinsidederivate='no' and $ddxinsidethisprobe='yes' or $_DERIVATE='yes']" >
                <admst:text test="[$finddt='no']" format="%(dxname($lhs)/[name='dxname']/value) = /*ep*/ $ep; // \n"/>
              </admst:if>
              <!-- <admst:text test="[$ddxinsidederivate='yes' and $ddxinsidethisprobe='no']" 
                   format="#endif //3\n"/>
              <admst:text test="[$ddxinsidethisprobe='yes']" format="#if defined(_DERIVATE2)\n"/> -->
              <admst:if test="[$ddxinsidethisprobe='no' or $_DERIVATE2='yes' ]">
                <admst:for-each select="$lhs[$ddxinsidethisprobe='yes']/probe">
                  <admst:variable name="epq" select="0.0"/>
                  <admst:variable name="qprobe" select="%(.)"/>
                  <admst:apply-templates select="[$isinside='1']/$rhs/tree" match="%(adms/datatypename)"/>
                  <admst:text test="[$finddt='no']" format="  %(ddxname($lhs)/[name='ddxname']/value) = $epq; // epq\n"/>
                </admst:for-each>
                <!-- <admst:text test="$lhs[$ddxinsidethisprobe='yes']" format="#endif // 5\n"/> -->
              </admst:if>
            </admst:for-each>
            <!-- <admst:text test="[$definedrequired='yes']" format="#endif // _DERIVATE \n"/> -->
          </admst:if>
          <admst:variable name="ddxinsidederivate" select="no"/>
        </admst:if>
        <admst:variable name="qprobe"/>
        <admst:apply-templates select="lhs" match="variable"/>


        <admst:if test="[$finddt='no']">
          <admst:if test="[$eval_kept='yes']">
            <admst:text format="$e = "/> %(e(rhs/tree)) <admst:text format=" /*tree, incomplete.*/ \n"/> 
          </admst:if>
          <admst:if test="[$eval_kept='no']">
            <admst:text format="$e = "/> %(e(rhs/tree)) ; <admst:text format=" /*tree $finddt*/ \n"/> 
          </admst:if>
        </admst:if>

        <admst:text test="[$finddt='yes']"  format="// ddt from ass \n %(e(rhs/tree))\n"/>

        <!--<admst:text format="EXIT_IF_ISNAN($e)\n"/>-->
      </admst:otherwise>
    </admst:choose>
    <admst:if test="[$finddt='no']">
      <admst:text test="rhs/function" format="} //rhs \n"/>
    </admst:if>
    <!--   <admst:text test="[dynamic='yes']" format="#endif // _DYNAMIC \n"/> -->
  </admst:if>
  <admst:text format="// FIXME done here\n"/>
</admst:template>
<!-- ---------------------------------------------------------- -->
<admst:template match="contribution:nonoise:mint">
<admst:message test="[/dbg_xml='yes']" format="*contribution:nonoise:mint*\n"/>
  <admst:text test="[dynamic='yes']" format="#if defined(_DYNAMIC) // fixm4\n"/>
  <admst:text test="rhs/function" format="{\n"/>
  <admst:apply-templates select="rhs/function" match="function:precomputation"/>
  <admst:apply-templates select="rhs[not(nilled(function))]" match="function:derivate:precomputation"/>
  <admst:variable name="sourcepnode" select="%(lhs/branch/pnode)"/>
  <admst:variable name="sourcennode" select="%(lhs/branch/nnode)"/>
  <admst:variable name="sourcepnodename" select="%($sourcepnode/name)"/>
  <admst:variable name="sourcennodename" select="%($sourcennode/name)"/>
  <admst:choose>
    <admst:when test="[dynamic='yes']">
      <admst:variable name="jname" select="dQ_dV"/>
      <admst:choose>
        <admst:when test="$sourcennode[grounded='no']">
          <admst:text format="charges_$(sourcepnodename)_$(sourcennodename) += %(e(rhs/tree));\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="charges_$(sourcepnodename)_$(sourcepnodename) += %(e(rhs/tree));\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="jname" select="dI_dV"/>
      <admst:choose>
        <admst:when test="$sourcennode[grounded='no']">
          <admst:text format="currents[$sourcepnodename*TotalNodes+$sourcennodename] += %(e(rhs/tree));\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="currents[$sourcepnodename*TotalNodes+$sourcepnodename] += %(e(rhs/tree));\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
  <admst:text format="#if defined(_DERIVATE) // FOO\n"/>
  <admst:for-each select="rhs/probe">
    <admst:variable name="probepnode" select="%(branch/pnode)"/>
    <admst:variable name="probennode" select="%(branch/nnode)"/>
    <admst:variable name="probepnodename" select="%($probepnode/name)"/>
    <admst:variable name="probennodename" select="%($probennode/name)"/>
    <admst:variable name="pprobe" select="%(.)"/>
    <admst:apply-templates select="../tree" match="%(adms/datatypename)"/>
    <admst:choose>
      <admst:when test="$probennode[grounded='no']">
        <admst:if test="$sourcennode[grounded='no']">
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probepnodename]+=$ep;\n"/>
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probennodename]-=$ep;\n"/>
          <admst:text format="  $jname[$sourcennodename*TotalNodes+$probepnodename]-=$ep;\n"/>
          <admst:text format="  $jname[$sourcennodename*TotalNodes+$probennodename]+=$ep;\n"/>
        </admst:if>
        <admst:if test="$sourcennode[grounded='yes']">
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probepnodename]+=$ep;\n"/>
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probennodename]-=$ep;\n"/>
        </admst:if>
      </admst:when>
      <admst:otherwise>
        <admst:if test="$sourcennode[grounded='no']">
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probepnodename]+=$ep;\n"/>
          <admst:text format="  $jname[$sourcennodename*TotalNodes+$probepnodename]-=$ep;\n"/>
        </admst:if>
        <admst:if test="$sourcennode[grounded='yes']">
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probepnodename]+=$ep;\n"/>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
  <admst:text format="#endif //88\n"/>
  <admst:text test="rhs/function" format="}\n"/>
  <admst:text select="[dynamic='yes']" format="#endif //98\n"/>
</admst:template>
<!-- ---------------------------------------------------------- -->
<admst:template match="contribution:nonoise">
<admst:message test="[/dbg_xml='yes']" format="*contribution:nonoise*\n"/>
  <admst:text format="// contribution ... \n"/>
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:text format="#if defined(_DYNAMIC)//fixme5\n"/>
      </admst:when>
    </admst:choose>
    <admst:text format="{\n"/>
    <admst:for-each select="rhs/function">

      <admst:value-of select="position(.)-1"/>

	<admst:apply-templates select="." match="function:getname">
      	<admst:value-of select="returned('function:getname')/value"/>
      </admst:apply-templates>
      
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="." match="ddx:function:computation"/>
  </admst:if>
  <admst:choose>
    <admst:when test="[dynamic='yes']">
      <admst:choose>
        <admst:when test="[$keep_ic='yes']">
          <admst:message format="keepic\n"/>
          <admst:text format="  _keep_dynamic_"/>
        </admst:when>
        <admst:when test="[$eval_kept='yes']">
          <admst:message format="keepic\n"/>
          <admst:text format="  _eval_kept_dynamic_"/>
        </admst:when>
        <admst:otherwise>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="lhs/branch/nnode[grounded='no']">
      <admst:apply-templates select="." match="residual2"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="lhs/branch/pnode/name"/>
      <admst:text format="//fixme residual1(%s,%((rhs/tree)))\n"/>
      <admst:apply-templates select="." match="residual1"/>
    </admst:otherwise>
  </admst:choose>
  <admst:for-each select="rhs/probe">
    <admst:text format="//Rhsp %(.)\n"/>
    <admst:variable name="probepnode" select="%(branch/pnode)"/>
    <admst:variable name="probennode" select="%(branch/nnode)"/>
    <admst:variable name="probepnodename" select="%($probepnode/name)"/>
    <admst:variable name="probennodename" select="%($probennode/name)"/>
    <admst:variable name="pprobe" select="%(.)"/>
    <admst:apply-templates select="../tree" match="%(adms/datatypename)"/>
    <admst:if test="branch/pnode[grounded='no']">
      <admst:if test="../../lhs/branch/pnode[grounded='no']">
        <admst:choose>
          <admst:when test="branch/nnode[grounded='no']">
            <admst:if test="../../lhs/branch/nnode[grounded='no']">
              <admst:apply-templates select="." match="jacobian4"/>
            </admst:if>
            <admst:if test="../../lhs/branch/nnode[grounded='yes']">
              <admst:apply-templates select="." match="jacobian2p"/>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:if test="../../lhs/branch/nnode[grounded='no']">
              <admst:apply-templates select="." match="jacobian2s"/>
            </admst:if>
            <admst:if test="../../lhs/branch/nnode[grounded='yes']">
              <!-- move up -->
              <admst:value-of select="branch/nnode/name"/>
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/nnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:variable name="Sp" select="%s"/>
              <admst:variable name="Sn" select="%s"/>
              <admst:variable name="Pp" select="%s"/>
              <admst:variable name="Pn" select="%s"/>
              <admst:apply-templates select="." match="jacobian1"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:if>
  </admst:for-each>
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:text format="} // // \n"/>
    <admst:text test="[dynamic='yes']" format="#endif /* _DYNAMIC */\n"/>
  </admst:if>
</admst:template>

<!-- ----------------------  residuals ------------------ -->
<admst:template match="residual2">
<admst:message test="[/dbg_xml='yes']" format="*residual2*\n"/>
  <admst:value-of select="lhs/branch/nnode/name"/>
  <admst:value-of select="lhs/branch/pnode/name"/>
  <admst:text format="// residual2(%s,%s,%(rhs/tree))//rhs/tree\n"/>
  <admst:value-of select="lhs/branch/nnode/name"/>
  <admst:value-of select="lhs/branch/pnode/name"/>

  <admst:variable name="Pp" select="%s"/>
  <admst:variable name="Pn" select="%s"/>
  <admst:choose> 
    <admst:when test="[dynamic='yes']">
	{  // former_eval_dynamic_residual2
        // rhs/tree should contain a ddt...
		double _i = %(e(rhs/tree));
		assert(is_number(_i));
        //error = NIintegrate(state_##p##_##n);
        //_eval_static_residual2($Pp,$Pn,v);
		it0[$(node_prefix)$Pp]-= _i;
		it0[$(node_prefix)$Pn]+= _i;
	}

    </admst:when>
    <admst:otherwise>
	{ // former_eval_static_residual2  (recheck: same as dynamic?)
		double vx = %(e(rhs/tree)); 
		assert(is_number(vx));
		it0[$node_prefix$Pp] -= vx;
		it0[$node_prefix$Pn] += vx;
	}

    </admst:otherwise>
    </admst:choose>
</admst:template>
<admst:template match="residual1">
<admst:message test="[/dbg_xml='yes']" format="*residual1*\n"/>
  <!-- <admst:value-of select="lhs/branch/pnode[grounded=yes]"/> -->
  <admst:value-of select="lhs/branch/pnode/name"/>
  <admst:text format="//fixme residual1(%s,%((rhs/tree)))\n"/>

  <admst:value-of select="lhs/branch/pnode/name"/>
  <admst:variable name="Pp" select="%s"/>
  <admst:choose> 
    <admst:when test="[dynamic='yes']">
	{  // former_eval_dynamic_residual2
        // rhs/tree should contain a ddt...
		double va = %(e(rhs/tree));
		assert(is_number(va));
        //_eval_static_residual1($Pp,v);
		it0[$node_prefix$Pp] -= va; 
	}

    </admst:when>
    <admst:otherwise>
	{ // former_eval_static_residual2  // same as dynamic?
		double vb = %(e(rhs/tree)); 
		assert(is_number(vb));
		it0[$node_prefix$Pp] -= vb;
	}

    </admst:otherwise>
  </admst:choose>

</admst:template>
<!-- ----------------------  jacobians ------------------ -->
<admst:template match="jacobian1">
<admst:message test="[/dbg_xml='yes']" format="*jacobian1*\n"/>
  <!-- why??? -->
              <admst:value-of select="branch/nnode/name"/>
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/nnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:variable name="Sp" select="%s"/>
              <admst:variable name="Sn" select="%s"/>
              <admst:variable name="Pp" select="%s"/>
              <admst:variable name="Pn" select="%s"/>
  <admst:choose> 
    <admst:when test="..[dynamic='yes']">

      { // former_eval_dynamic_jacobian1 
        double ep=$ep; 
        double geq=(ep)*(CKTag0);
        double ceq=geq*NP($Pp);
        // _eval_static_residual1($Sp, -ceq)
        it0[n_$Sp]-=ceq; 

        <admst:if test="[$eval_mode='tr']">
          _write_ptr($Sp, $Pp, geq);
        </admst:if>
        <admst:if test="[$eval_mode='ac']">
          _write_JS($Sp, $Pp, ep);
        </admst:if>

        }

    </admst:when>
    <admst:otherwise>
       { // former_eval_stat_jacobian1 \n
        double ep=$ep; 
        // _eval_static_residual1($Sp,-ep*NP(Pp));
	it0[n_$Sp]-=ep*NP($Pp); \
      <admst:if test="[$eval_mode='tr']">
        _write_ptr($Sp, $Pp, ep);
      </admst:if>
      <admst:if test="[$eval_mode='ac']">
        _write_JS($Sp, $Pp, ep);
      </admst:if>
      }
    </admst:otherwise>
  </admst:choose>
</admst:template>
<!-- ----------------------  jacobians ------------------ -->
<admst:template match="jacobian4">
<admst:message test="[/dbg_xml='yes']" format="*jacobian4*\n"/>
  <admst:value-of select="branch/nnode/name"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:value-of select="../../lhs/branch/nnode/name"/>
  <admst:value-of select="../../lhs/branch/pnode/name"/>
  <admst:variable name="Sp" select="%s"/>
  <admst:variable name="Sn" select="%s"/>
  <admst:variable name="Pp" select="%s"/>
  <admst:variable name="Pn" select="%s"/>
  <admst:choose> 
    <admst:when test="..[dynamic='yes']">
	{  // former_eval_dynamic_jac4
		double ep=$ep; 
		double geq=(ep)*(CKTag0);
		double ceq=geq*BP($Pp,$Pn);
		// _eval_static_residual2($Sn, $Sp, ceq)
		it0[$(node_prefix)$Sp]+=ceq;
		it0[$(node_prefix)$Sn]-=ceq;
      <admst:if test="[$eval_mode='tr']">
        _write_ptr($Sp, $Pp, geq);
        _write_ptr($Sn, $Pn, geq);
        _write_ptr($Sp, $Pn, -geq);
        _write_ptr($Sn, $Pp, -geq);
      </admst:if>
      <admst:if test="[$eval_mode='ac']">
        _write_JD($Sp, $Pp, ep);
        _write_JD($Sn, $Pn, ep);
        _write_JD($Sp, $Pn, -ep);
        _write_JD($Sn, $Pp, -ep);
      </admst:if>
      }

    </admst:when>
    <admst:otherwise>
	{ // former_eval_stat_j4 
		double ep=$ep; 
      // _eval_static_residual2($Sp,$Sn,-ep*BP($Pp,$Pn));
		it0[$(node_prefix)$Sp]+= ep*BP($Pp,$Pn);
		it0[$(node_prefix)$Sn]-= ep*BP($Pp,$Pn);

      <admst:if test="[$eval_mode='tr']">
        _write_ptr($Sp, $Pp, ep);
        _write_ptr($Sn, $Pn, ep);
        _write_ptr($Sp, $Pn, -ep);
        _write_ptr($Sn, $Pp, -ep);
      </admst:if>

      <admst:if test="[$eval_mode='ac']">
          _write_JS($Sp, $Pp, ep);
          _write_JS($Sn, $Pn, ep);
          _write_JS($Sp, $Pn, -ep);
          _write_JS($Sn, $Pp, -ep);
        </admst:if>
        }

    </admst:otherwise>
  </admst:choose>
</admst:template>
<admst:template match="jacobian2p">
<admst:message test="[/dbg_xml='yes']" format="*jacobian2p*\n"/>
  <admst:value-of select="branch/nnode/name"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:value-of select="../../lhs/branch/pnode/name"/>
  <admst:variable name="Sp" select="%s"/>
  <admst:variable name="Pp" select="%s"/>
  <admst:variable name="Pn" select="%s"/>

  <admst:choose> 
    <admst:when test="..[dynamic='yes']">
       { //  _eval_dynamic_ \n
          double geq=($ep)*(CKTag0);\
          double ceq=geq*BP(Pp,Pn);\
          // _eval_static_residual1($Sp, -ceq)\
	  it0[n_$Sp]+=ceq;

      <admst:if test="[$eval_mode='tr']">
          _write_ptr($Sp, $Pp, geq);
          _write_ptr($Sp, $Pn, -geq);
      </admst:if>
      <admst:if test="[$eval_mode='ac']">
          _write_JD($Sp, $Pp, $ep);
          _write_JD($Sp, $Pn, -$ep);
      </admst:if>
      }

    </admst:when>
      <admst:otherwise>
          { // former_eval_static_ \n
          double ep=$ep;
          //        _eval_static_residual1(Sp,-ep*BP(Pp,Pn))
	  it0[n_$Sp] += ep*BP($Pp,$Pn);
      <admst:if test="[$eval_mode='tr']">
        _write_ptr($Sp, $Pp, ep);
        _write_ptr($Sp, $Pn, -ep);
        </admst:if>
      <admst:if test="[$eval_mode='ac']">
        _write_JS($Sp, $Pp, ep);
        _write_JS($Sp, $Pn, -ep);
    </admst:if>
    }
    </admst:otherwise>
  </admst:choose>
</admst:template>
<!-- ------------------------------------------------ -->
<admst:template match="jacobian2s">
<admst:message test="[/dbg_xml='yes']" format="*jacobian2s*\n"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:value-of select="../../lhs/branch/nnode/name"/>
  <admst:value-of select="../../lhs/branch/pnode/name"/>
  <admst:variable name="Sp" select="%s"/>
  <admst:variable name="Sn" select="%s"/>
  <admst:variable name="Pp" select="%s"/>
  <admst:choose> 
    <admst:when test="..[dynamic='yes']">
	{ // former_eval_dynamic_jacobian2s  
		double e=$ep;
		double geq=e*(CKTag0);
		double ceq=geq*NP($Pp);
        // _eval_static_residual2($Sn, $Sp, ceq);
		it0[$(node_prefix)$Sp] -= ceq;
		it0[$(node_prefix)$Sn] += ceq;
        <admst:if test="[$eval_mode='tr']">
        _write_ptr($Sp, $Pp, geq);
        _write_ptr($Sn, $Pp, -geq);
      </admst:if>

        <admst:if test="[$eval_mode='ac']">
        _write_JD($Sp, $Pp, e);
        _write_JD($Sn, $Pp, -e);
      </admst:if>
	}
    </admst:when>

    <admst:otherwise>
	{ // former_eval_static_jacobian2s
        double e=$e;
        //_eval_static_residual2($Sp,$Sn,-e*NP($Pp));
		it0[$(node_prefix)$Sp] += e*NP($Pp);
		it0[$(node_prefix)$Sn] -= e*NP($Pp);		
      <admst:if test="[$eval_mode='tr']">
        _write_ptr($Sp, $Pp, e);
        _write_ptr($Sn, $Pp, -e);
        </admst:if>
      <admst:if test="[$eval_mode='ac']">
        _write_JS($Sp, $Pp, e);
        _write_JS($Sn, $Pp, -e);
        </admst:if>
	}
    </admst:otherwise>
  </admst:choose>
</admst:template>
<!-- analog//conditional -->
<admst:template match="conditional">
<admst:message test="[/dbg_xml='yes']" format="*conditional*\n"/>
  <admst:text select="if[dynamic='yes']" format="#ifdef _DYNAMIC\n"/>
  <admst:text test="if/function" format="{ // conditional\n"/>
  <admst:apply-templates select="if/function" match="function:precomputation"/>
  <admst:text format="if\n(%(e(if/tree))) //conditional \n"/>
  <admst:text select="then/adms[datatypename!='block']" format="{\n"/>
  <admst:apply-templates select="then" match="%(adms/datatypename)"/>
  <admst:text select="then/adms[datatypename!='block']" format="}//conditional\n"/>
  <admst:if test="else">
    <admst:text format="else // conditional\n"/>
    <admst:text test="else/adms[datatypename!='block']" format="{ // conditional.\n"/>
    <admst:apply-templates select="else" match="%(adms/datatypename)"/>
    <admst:text test="else/adms[datatypename!='block']" format="} // conditional.\n"/>
  </admst:if>
  <admst:text test="if/function" format="} // conditional\n"/>
  <admst:text select="if[dynamic='yes']" format="#endif /* if(...) */\n"/>
</admst:template>

<!-- analog//nilled -->
<admst:template match="nilled">
<admst:message test="[/dbg_xml='yes']" format="*nilled*\n"/>
</admst:template>

<!-- analog//whileloop -->
<admst:template match="whileloop">
<admst:message test="[/dbg_xml='yes']" format="*whileloop*\n"/>
  <admst:text select="while[dynamic='yes']" format="#ifdef _DYNAMIC\n"/>
  <admst:variable name="SkipFVariable" select="y"/>
  <admst:text format="while\n(%(e(while/tree)))\n"/>
  <admst:variable name="SkipFVariable" select="n"/>
  <admst:text select="whileblock/adms[datatypename!='block']" format="{\n"/>
  <admst:apply-templates select="whileblock" match="%(adms/datatypename)"/>
  <admst:text select="whileblock/adms[datatypename!='block']" format="}\n"/>
  <admst:text select="while[dynamic='yes']" format="#endif /*&lt;/dynamic_while&gt;*/\n"/>
</admst:template>

<!-- analog//callfunctions -->
<admst:template match="callfunction">
<admst:message test="[/dbg_xml='yes']" format="*callfunction*\n"/>
	<admst:apply-templates select="." match="callfunction"/>
</admst:template>

<!-- analog/code -->
<!-- save all variables used for local declaration -->
<admst:variable name="ddxinsidederivate" select="no"/>

<admst:template match="variable:declaration">
<admst:message test="[/dbg_xml='yes']" format="*variable:declaration*\n"/>
  <admst:variable name="myvariable" select="%(.)"/>
  <admst:new datatype="list" arguments="list of ddx probes">
    <admst:variable name="ddxprobes" select="%(.)"/>
    <admst:for-each select="$myvariable/probe">
      <admst:variable name="pprobe" select="%(.)"/>
      <admst:push into="$ddxprobes/item" 
        select="$myvariable/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]/$pprobe" 
        onduplicate="ignore"/>
    </admst:for-each>
  </admst:new>
  <admst:if test="block/adms[datatypename='module']">
    <admst:text test="[static='no' and dynamic='yes']" format="// #if defined(_DYNAMIC) // fixme\n"/>
    <admst:if   test="[static='yes' or dynamic='no' or $_DYNAMIC='yes']">

    <admst:text test="[scope='local']" format="%(vtype(.)) %(name);\n"/>
    <admst:if test="[insource='yes']/probe">
      <admst:for-each select="probe">
        <admst:variable name="pprobe" select="%(.)"/>
        <admst:if test="../ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
          <admst:variable name="ddxinsidederivate" select="yes"/>
        </admst:if>
      </admst:for-each>
      <!--       <admst:choose>
        <admst:when test="[$ddxinsidederivate='yes']">
          <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="#if defined(_DERIVATE) //FIXME A /n"/>
        </admst:otherwise>
      </admst:choose> -->
      <admst:if test="[ $ddxinsidederivate='no' or $_DERIVATEFORDDX='yes' or ( $_DERIVATEFORDDX='no' and  $_DERIVATE='yes'   )    ]" >

        <admst:text select="probe"
          format="double %(../name)_%(nature/access)%(branch/pnode/name)_%(branch/nnode/name);\n"/>
        <!-- <admst:text test="[$ddxinsidederivate='yes']" format="#if defined(_DERIVATE2)\n"/> --> 
        <admst:if test="[ $ddxinsidederivate='no'  or $_DERIVATE2='yes']" >
          <admst:for-each select="$ddxprobes/item">
            <admst:variable name="pprobe" select="%(.)"/>
            <admst:for-each select="$myvariable/probe">
              <admst:variable name="qprobe" select="%(.)"/>
              <admst:text format="  double %(ddxname($myvariable)/[name='ddxname']/value);\n"/>
            </admst:for-each>
          </admst:for-each>
        </admst:if>
      <!-- <admst:text test="[$ddxinsidederivate='yes']" format="#endif\n"/> -->
      <admst:variable name="ddxinsidederivate" select="no"/>
      <!-- <admst:text format="#endif // FIX 5\n"/> -->
      </admst:if>
    </admst:if>
    </admst:if>
    <admst:text test="[static='no' and dynamic='yes']" format="// #endif _DYNAMIC\n"/>
  </admst:if>
</admst:template>
<admst:template match="block:local:declaration">
<admst:message test="[/dbg_xml='yes']" format="*block:local:declaration*\n"/>
  <admst:choose>
    <admst:when test="adms[datatypename='assignment']">
      <admst:push into="module/evaluation/variable" select="lhs" onduplicate="ignore"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:apply-templates select="item" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="then" match="block:local:declaration"/>
      <admst:apply-templates select="else" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']"/>
    <admst:when test="adms[datatypename='callfunction']"/>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:fatal format="'datatypename=%(adms/datatypename)': should not be reached %s\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>
<!-- -------------------------------------------------- -->
<admst:template match="analog:evaluate">
<admst:message test="[/dbg_xml='yes']" format="*analog:evaluate*\n"/>
  <admst:text select="$fnoise/item" format="fpnoise%(index($fnoise/item,.))=0.0;
    fenoise%(index($fnoise/item,.))=0.0;\n"/>
  <admst:text select="$tnoise/item" format="tnoise%(index($tnoise/item,.))=0.0;\n"/>
  <admst:text select="$wnoise/item" format="wnoise%(index($wnoise/item,.))=0.0;\n"/>

  <!-- local variable declarations. move to template? -->
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name!='initial_model' and name!='initial_instance']">
      <admst:text format="// declaration1\n"/>
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
    <admst:if test="adms[datatypename!='block']">
      <admst:text format="// declaration2\n"/>
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:text format="// declaration3\n"/>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <!-- local variable declarations -->

  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:choose>
      <admst:when test="adms[datatypename!='block']">
        <admst:apply-templates select="." match="%(adms/datatypename)"/>
      </admst:when>
      <admst:otherwise>
        <admst:if test="[name!='initial_model' and name!='initial_instance']">
          <admst:text format="//bug -- parts of this has been done in tr_begin.\n"/>
          <admst:apply-templates select="." match="block"/>
          <admst:text format="// end bug?\n"/>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
</admst:template>
<!-- -------------------------------------------------------------------- -->
<admst:template match="analog:initializeModel">
<admst:message test="[/dbg_xml='yes']" format="*analog:initializeModel*\n"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_model']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_model']">
      <admst:apply-templates select="." match="block"/>
    </admst:if>
  </admst:for-each>
</admst:template>
<!-- -------------------------------------------------------------------- -->
<admst:template match="analog:initializeInstance">
<admst:message test="[/dbg_xml='yes']" format="*analog:initializeInstance*\n"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_instance']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_instance']">
      <admst:apply-templates select="." match="block"/>
    </admst:if>
  </admst:for-each>
</admst:template>

<!--
* This template returns the description of an instance or 
* a model parameter. It works for both formats of :
*   `ATTR(info="description"  ...)
* or
*   `ATTR(desc="description"  ...)
* This template is used in the creation of the mint:defineParameters 
* routine. If there is no description given in the VerilogA file, 
* it returns a NULL. The returned value is used in the 'description'
* field of the mint_param_xxx file, where xxx is [integer|real|string]
-->
<admst:template match="variable:desc">
<admst:message test="[/dbg_xml='yes']" format="*variable:desc*\n"/>
  <admst:choose>
    <admst:when test="attribute[name='desc' or name='info']">
      <admst:return name="variable:desc" value="&quot;%(attribute[name='desc' or name='info']/value)&quot;"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="variable:desc" value="NULL"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
* This template returns the unit of an instance or 
* a model parameter as given in the VA file.
* This template is used in the creation of the mint:defineParameters 
* routine. If there is no 'unit' string given in the VerilogA file, 
* it returns a NULL. The returned value is used in the 'unit'
* field of the mint_param_xxx file, where xxx is [integer|real|string]
-->
<admst:template match="variable:unit">
<admst:message test="[/dbg_xml='yes']" format="*variable:unit*\n"/>
  <admst:choose>
    <admst:when test="attribute[name='unit']">
      <admst:return name="variable:unit" value="&quot;%(attribute[name='unit']/value)&quot;"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="variable:unit" value="NULL"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
* This template returns the default value of an instance or 
* a model parameter as given in the VA file.
* This template is used in the creation of the mint:defineParameters 
* routine. The returned value is used in the 'default'
* field of the mint_param_xxx file, where xxx is [integer|real|string]
-->

<admst:template match="variable:paramdef">
<admst:message test="[/dbg_xml='yes']" format="*variable:paramdef*\n"/>
  <admst:return name="name" value="%(name)"/>
  <admst:apply-templates select="." match="variable:desc">
    <admst:return name="desc" value="%(returned('variable:desc')/value)"/>
  </admst:apply-templates>
  <admst:apply-templates select="." match="variable:unit">
    <admst:return name="unit" value="%(returned('variable:unit')/value)"/>
  </admst:apply-templates>
  <admst:return name="minttype" value="%(type)"/>
</admst:template>

<!-- ------------------------------------ -->
<admst:template match="c:math_h">
<admst:message test="[/dbg_xml='yes']" format="*c:math_h*\n"/>
// *** arithmetics ***
<admst:text format="\n\n"/>
</admst:template>
<!-- ------------------------------------------- -->
<admst:template match="wrapper">
<admst:message test="[/dbg_xml='yes']" format="*wrapper*\n"/>
// *** wrapper ***
#define m _model


<admst:if test="/module/variable[derivate='yes' and insource='yes']">
<admst:variable name="requiredderivateforddx" select="yes"/>
</admst:if>
<admst:text format="\n"/>
</admst:template>


</admst>
