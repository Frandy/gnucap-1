/* $Id: d_rcd.model,v 1.2 2010-07-09 12:14:22 felix Exp $ -*- C++ -*-
vim:ts=8:sw=2:et:
*/


/* This file is automatically generated. DO NOT EDIT */


#include "e_aux.h"
#include "e_storag.h"
// #include "d_mos_base.h"

#include "globals.h"
#include "e_elemnt.h"
#include "d_rcd.h"
/*--------------------------------------------------------------------------*/
const double NA(NOT_INPUT);
const double INF(BIGBIG);
/*--------------------------------------------------------------------------*/
int MODEL_BUILT_IN_RCD::_count = 0;
/*--------------------------------------------------------------------------*/
namespace MODEL_BUILT_IN_RCD_DISPATCHER { 
  static DEV_BUILT_IN_RCD p1d;
  static MODEL_BUILT_IN_RCD p1(&p1d);
  static DISPATCHER<MODEL_CARD>::INSTALL
    d1(&model_dispatcher, "rcdmodel", &p1);
}
/*--------------------------------------------------------------------------*/
void SDP_BUILT_IN_RCD::init(const COMMON_COMPONENT* cc)
{
  assert(cc);
  SDP_CARD::init(cc);
}
/*--------------------------------------------------------------------------*/
TDP_BUILT_IN_RCD::TDP_BUILT_IN_RCD(const DEV_BUILT_IN_RCD*)
{
}
/*--------------------------------------------------------------------------*/
MODEL_BUILT_IN_RCD::MODEL_BUILT_IN_RCD(const BASE_SUBCKT* p)
  :MODEL_CARD(p),
   anneal(true),
   Remodel(1e6),
   foo(1e6),
   cjsw(0.0),
   flags(int(USE_OPT)),
   mos_level(0)
{
  if (ENV::run_mode != rPRE_MAIN) {
    ++_count;
  }else{
  }
  set_default(&_tnom_c, OPT::tnom_c);
}
/*--------------------------------------------------------------------------*/
MODEL_BUILT_IN_RCD::MODEL_BUILT_IN_RCD(const MODEL_BUILT_IN_RCD& p)
  :MODEL_CARD(p),
   anneal(p.anneal),
   Remodel(p.Remodel),
   foo(p.foo),
   cjsw(p.cjsw),
   flags(p.flags),
   mos_level(p.mos_level)
{
  if (ENV::run_mode != rPRE_MAIN) {
    ++_count;
  }else{untested();//194
  }
}
/*--------------------------------------------------------------------------*/
std::string MODEL_BUILT_IN_RCD::dev_type()const
{
  if (dummy == true) {
    return "rcdmodel";
  }else{untested();//235
    return MODEL_CARD::dev_type();
  }
}
/*--------------------------------------------------------------------------*/
void MODEL_BUILT_IN_RCD::set_dev_type(const std::string& new_type)
{
  if (Umatch(new_type, "rcdmodel ")) {
    dummy = true;
  }else{
    MODEL_CARD::set_dev_type(new_type);
  }
}
/*--------------------------------------------------------------------------*/
void MODEL_BUILT_IN_RCD::precalc_first()
{
    const CARD_LIST* par_scope = scope();
    assert(par_scope);
    MODEL_CARD::precalc_first();
    e_val(&(this->anneal), true, par_scope);
    e_val(&(this->Remodel), 1e6, par_scope);
    e_val(&(this->foo), 1e6, par_scope);
    e_val(&(this->cjsw), 0.0, par_scope);
    e_val(&(this->flags), int(USE_OPT), par_scope);
    e_val(&(this->mos_level), 0, par_scope);
    // final adjust: code_pre
    // final adjust: override
    // final adjust: raw
    e_val(&(this->anneal), true, par_scope);
    e_val(&(this->Remodel), 1e6, par_scope);
    e_val(&(this->foo), 1e6, par_scope);
    e_val(&(this->cjsw), 0.0, par_scope);
    e_val(&(this->flags), int(USE_OPT), par_scope);
    e_val(&(this->mos_level), 0, par_scope);
    // final adjust: mid
    // final adjust: calculated
    // final adjust: post
    // final adjust: done
}
/*--------------------------------------------------------------------------*/
void MODEL_BUILT_IN_RCD::precalc_last()
{
    MODEL_CARD::precalc_last();
}
/*--------------------------------------------------------------------------*/
SDP_CARD* MODEL_BUILT_IN_RCD::new_sdp(COMMON_COMPONENT* c)const
{
  assert(c);
  if (COMMON_BUILT_IN_RCD* cc = dynamic_cast<COMMON_BUILT_IN_RCD*>(c)) {
    if (cc->_sdp) {
      cc->_sdp->init(cc);
      return cc->_sdp;
    }else{
      delete cc->_sdp;
      return new SDP_BUILT_IN_RCD(c);
    }
  }else{
    return MODEL_CARD::new_sdp(c);
  }
}
/*--------------------------------------------------------------------------*/
void MODEL_BUILT_IN_RCD::set_param_by_index(int i, std::string& value, int offset)
{
  switch (MODEL_BUILT_IN_RCD::param_count() - 1 - i) {
  case 0: untested(); break;
  case 1: _tnom_c = value; break;
  case 2: anneal = value; break;
  case 3: Remodel = value; break;
  case 4: foo = value; break;
  case 5: cjsw = value; break;
  case 6: flags = value; break;
  case 7: mos_level = value; break;
  default: throw Exception_Too_Many(i, 7, offset); break;
  }
}
/*--------------------------------------------------------------------------*/
bool MODEL_BUILT_IN_RCD::param_is_printable(int i)const
{
  switch (MODEL_BUILT_IN_RCD::param_count() - 1 - i) {
  case 0:  return (false);
  case 1:  return (true);
  case 2:  return (true);
  case 3:  return (true);
  case 4:  return (true);
  case 5:  return (cjsw != 0.);
  case 6:  return (!(flags & USE_OPT));
  case 7:  return (mos_level.has_hard_value());
  default: return false;
  }
}
/*--------------------------------------------------------------------------*/
std::string MODEL_BUILT_IN_RCD::param_name(int i)const
{
  switch (MODEL_BUILT_IN_RCD::param_count() - 1 - i) {
  case 0:  return "=====";
  case 1:  return "tnom";
  case 2:  return "anneal";
  case 3:  return "rem";
  case 4:  return "sth";
  case 5:  return "cjsw";
  case 6:  return "flags";
  case 7:  return "mos_level";
  default: return "";
  }
}
/*--------------------------------------------------------------------------*/
std::string MODEL_BUILT_IN_RCD::param_name(int i, int j)const
{
  if (j == 0) {
    return param_name(i);
  }else if (j == 1) {
    switch (MODEL_BUILT_IN_RCD::param_count() - 1 - i) {
    case 0:  return "";
    case 1:  return "";
    case 2:  return "";
    case 3:  return "";
    case 4:  return "";
    case 5:  return "cjs";
    case 6:  return "";
    case 7:  return "";
    default: return "";
    }
  }else{
    return "";
  }
}
/*--------------------------------------------------------------------------*/
std::string MODEL_BUILT_IN_RCD::param_value(int i)const
{
  switch (MODEL_BUILT_IN_RCD::param_count() - 1 - i) {
  case 0:  unreachable(); return "";
  case 1:  return _tnom_c.string();
  case 2:  return anneal.string();
  case 3:  return Remodel.string();
  case 4:  return foo.string();
  case 5:  return cjsw.string();
  case 6:  return flags.string();
  case 7:  return mos_level.string();
  default: return "";
  }
}
/*--------------------------------------------------------------------------*/
bool MODEL_BUILT_IN_RCD::is_valid(const COMPONENT* d)const
{
  assert(d);
  return MODEL_CARD::is_valid(d);
}
/*--------------------------------------------------------------------------*/
void MODEL_BUILT_IN_RCD::tr_eval(COMPONENT*)const
{untested();//425
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
int DEV_BUILT_IN_RCD::_count = -1;
int COMMON_BUILT_IN_RCD::_count = -1;
static COMMON_BUILT_IN_RCD Default_BUILT_IN_RCD(CC_STATIC);
/*--------------------------------------------------------------------------*/
COMMON_BUILT_IN_RCD::COMMON_BUILT_IN_RCD(int c)
  :COMMON_COMPONENT(c),
   perim(0.0),
   weight(1.0),
   Recommon(1e5),
   Rccommon0(10.0),
   Rccommon1(10.0),
   dummy_capture(true),
   dummy_emit(true),
   _sdp(0),
   cj_adjusted(NA)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_BUILT_IN_RCD::COMMON_BUILT_IN_RCD(const COMMON_BUILT_IN_RCD& p)
  :COMMON_COMPONENT(p),
   perim(p.perim),
   weight(p.weight),
   Recommon(p.Recommon),
   Rccommon0(p.Rccommon0),
   Rccommon1(p.Rccommon1),
   dummy_capture(p.dummy_capture),
   dummy_emit(p.dummy_emit),
   _sdp(0),
   cj_adjusted(p.cj_adjusted)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_BUILT_IN_RCD::~COMMON_BUILT_IN_RCD()
{
  --_count;
  delete _sdp;
}
/*--------------------------------------------------------------------------*/
bool COMMON_BUILT_IN_RCD::operator==(const COMMON_COMPONENT& x)const
{
  const COMMON_BUILT_IN_RCD* p = dynamic_cast<const COMMON_BUILT_IN_RCD*>(&x);
  return (p
    && perim == p->perim
    && weight == p->weight
    && Recommon == p->Recommon
    && Rccommon0 == p->Rccommon0
    && Rccommon1 == p->Rccommon1
    && dummy_capture == p->dummy_capture
    && dummy_emit == p->dummy_emit
    && _sdp == p->_sdp
    && COMMON_COMPONENT::operator==(x));
}
/*--------------------------------------------------------------------------*/
void COMMON_BUILT_IN_RCD::set_param_by_index(int I, std::string& Value, int Offset)
{
  switch (COMMON_BUILT_IN_RCD::param_count() - 1 - I) {
  case 0:  perim = Value; break;
  case 1:  weight = Value; break;
  case 2:  Recommon = Value; break;
  case 3:  Rccommon0 = Value; break;
  case 4:  Rccommon1 = Value; break;
  case 5:  dummy_capture = Value; break;
  case 6:  dummy_emit = Value; break;
  default: COMMON_COMPONENT::set_param_by_index(I, Value, Offset);
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_BUILT_IN_RCD::param_is_printable(int i)const
{
  switch (COMMON_BUILT_IN_RCD::param_count() - 1 - i) {
  case 0:  return (perim != 0.);
  case 1:  return (true);
  case 2:  return (true);
  case 3:  return (true);
  case 4:  return (true);
  case 5:  return (true);
  case 6:  return (true);
  default: return COMMON_COMPONENT::param_is_printable(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_BUILT_IN_RCD::param_name(int i)const
{
  switch (COMMON_BUILT_IN_RCD::param_count() - 1 - i) {
  case 0:  return "perim";
  case 1:  return "weight";
  case 2:  return "re";
  case 3:  return "rc0";
  case 4:  return "rc1";
  case 5:  return "rcdummy";
  case 6:  return "redummy";
  default: return COMMON_COMPONENT::param_name(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_BUILT_IN_RCD::param_name(int i, int j)const
{
  if (j == 0) {
    return param_name(i);
  }else if (j == 1) {
    switch (COMMON_BUILT_IN_RCD::param_count() - 1 - i) {
    case 0:  return "";
    case 1:  return "";
    case 2:  return "";
    case 3:  return "";
    case 4:  return "";
    case 5:  return "";
    case 6:  return "";
    default: return "";
    }
  }else{untested();//281
    return COMMON_COMPONENT::param_name(i, j);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_BUILT_IN_RCD::param_value(int i)const
{
  switch (COMMON_BUILT_IN_RCD::param_count() - 1 - i) {
  case 0:  return perim.string();
  case 1:  return weight.string();
  case 2:  return Recommon.string();
  case 3:  return Rccommon0.string();
  case 4:  return Rccommon1.string();
  case 5:  return dummy_capture.string();
  case 6:  return dummy_emit.string();
  default: return COMMON_COMPONENT::param_value(i);
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_BUILT_IN_RCD::expand(const COMPONENT* d)
{
  COMMON_COMPONENT::expand(d);
  attach_model(d);
  COMMON_BUILT_IN_RCD* c = this;
  const MODEL_BUILT_IN_RCD* m = dynamic_cast<const MODEL_BUILT_IN_RCD*>(model());
  if (!m) {
    throw Exception_Model_Type_Mismatch(d->long_label(), modelname(), "rcd");
  }else{
  }
  // size dependent
  //delete _sdp;
  _sdp = m->new_sdp(this);
  assert(_sdp);
  const SDP_BUILT_IN_RCD* s = prechecked_cast<const SDP_BUILT_IN_RCD*>(_sdp);
  assert(s);

  // subcircuit commons, recursive
  assert(c == this);
}
/*--------------------------------------------------------------------------*/
void COMMON_BUILT_IN_RCD::precalc_first(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_first(par_scope);
    e_val(&(this->perim), 0.0, par_scope);
    e_val(&(this->weight), 1.0, par_scope);
    e_val(&(this->Recommon), 1e5, par_scope);
    e_val(&(this->Rccommon0), 10.0, par_scope);
    e_val(&(this->Rccommon1), 10.0, par_scope);
    e_val(&(this->dummy_capture), true, par_scope);
    e_val(&(this->dummy_emit), true, par_scope);
}
/*--------------------------------------------------------------------------*/
void COMMON_BUILT_IN_RCD::precalc_last(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_last(par_scope);
  COMMON_BUILT_IN_RCD* c = this;
  const MODEL_BUILT_IN_RCD* m = prechecked_cast<const MODEL_BUILT_IN_RCD*>(model());
    // final adjust: code_pre
    // final adjust: override
    // final adjust: raw
    e_val(&(this->perim), 0.0, par_scope);
    e_val(&(this->weight), 1.0, par_scope);
    e_val(&(this->Recommon), 1e5, par_scope);
    e_val(&(this->Rccommon0), 10.0, par_scope);
    e_val(&(this->Rccommon1), 10.0, par_scope);
    e_val(&(this->dummy_capture), true, par_scope);
    e_val(&(this->dummy_emit), true, par_scope);
    // final adjust: mid
    // final adjust: calculated
    cj_adjusted = 19.0;
    // final adjust: post
    // final adjust: done

  // size dependent
  //delete _sdp;
  _sdp = m->new_sdp(this);
  assert(_sdp);
  const SDP_BUILT_IN_RCD* s = prechecked_cast<const SDP_BUILT_IN_RCD*>(_sdp);
  assert(s);

  // subcircuit commons, recursive
  assert(c == this);
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
namespace DEV_BUILT_IN_RCD_DISPATCHER { 
  static DEV_BUILT_IN_RCD p0;
  static DISPATCHER<CARD>::INSTALL
    d0(&device_dispatcher, "Z|rcd", &p0);
}
/*--------------------------------------------------------------------------*/
static EVAL_BUILT_IN_RCD_CRc Eval_CRc(CC_STATIC);
void EVAL_BUILT_IN_RCD_CRc::tr_eval(ELEMENT* d)const
{
  assert(d);
  DEV_BUILT_IN_RCD* p = prechecked_cast<DEV_BUILT_IN_RCD*>(d->owner());
  assert(p);
  const COMMON_BUILT_IN_RCD* c = prechecked_cast<const COMMON_BUILT_IN_RCD*>(p->common());
  assert(c);
  const SDP_BUILT_IN_RCD* s = prechecked_cast<const SDP_BUILT_IN_RCD*>(c->sdp());
  assert(s);
  const MODEL_BUILT_IN_RCD* m = prechecked_cast<const MODEL_BUILT_IN_RCD*>(c->model());
  assert(m);

        untested();

    double _c[3] = { c->Rccommon0, c->Rccommon1, 0 };
    double x = (d->_y[0].x);
//    trace1("Rc", x);
    double f0 = 0.;
    double f1 = 0.;
    for (size_t i=1; i>0; --i) {
      f0 += _c[i];
      f0 *= x;
      f1 *= x;
      f1 += _c[i]*int(i);
    }
    f0 += _c[0];
    d->_y[0] = FPOLY1(x, f0, f1);

 //  d->set_converged(d->conv_check());
}
/*--------------------------------------------------------------------------*/
static EVAL_BUILT_IN_RCD_Ye Eval_Ye(CC_STATIC);
void EVAL_BUILT_IN_RCD_Ye::tr_eval(ELEMENT* d)const
{
  assert(d);
  DEV_BUILT_IN_RCD* p = prechecked_cast<DEV_BUILT_IN_RCD*>(d->owner());
  assert(p);
  const COMMON_BUILT_IN_RCD* c = prechecked_cast<const COMMON_BUILT_IN_RCD*>(p->common());
  assert(c);
  const SDP_BUILT_IN_RCD* s = prechecked_cast<const SDP_BUILT_IN_RCD*>(c->sdp());
  assert(s);
  const MODEL_BUILT_IN_RCD* m = prechecked_cast<const MODEL_BUILT_IN_RCD*>(c->model());
  assert(m);

    untested0("Ye");
    region_t oldregion = p->_region;
    hp_float_t& volts = d->_y[0].x;

    if ( volts >= 0 ){
      // untested0( "FORWARD" );
      p->_region = FORWARD;
      d->_y[0].f1 = 1 / c->Recommon;
      d->_y[0].f0 = d->_y[0].x / c->Recommon;
    }else{               
      // untested0( "REVERSE" );
      p->_region = REVERSE;
      d->_y[0].f1 = 0;
      d->_y[0].f0 = 0;
    }
    if (oldregion != p->_region  )
    {
      untested0("switching region");
      d->_sim->_fulldamp = true;
    }
}
/*--------------------------------------------------------------------------*/
DEV_BUILT_IN_RCD::DEV_BUILT_IN_RCD()
  :BASE_SUBCKT(),
   // input parameters,
   // calculated parameters,
   _region(UNKNOWN),
   // netlist,
   _Ccg(0),
   _Ye(0),
   _Re(0),
   _Rc(0),
   _CRc(0)
{
  _n = _nodes;
  attach_common(&Default_BUILT_IN_RCD);
  ++_count;
  // overrides
}
/*--------------------------------------------------------------------------*/
DEV_BUILT_IN_RCD::DEV_BUILT_IN_RCD(const DEV_BUILT_IN_RCD& p)
  :BASE_SUBCKT(p),
   // input parameters,
   // calculated parameters,
   _region(p._region),
   // netlist,
   _Ccg(0),
   _Ye(0),
   _Re(0),
   _Rc(0),
   _CRc(0)
{
  _n = _nodes;
  for (int ii = 0; ii < max_nodes() + int_nodes(); ++ii) {
    _n[ii] = p._n[ii];
  }
  ++_count;
  // overrides
}
/*--------------------------------------------------------------------------*/
void DEV_BUILT_IN_RCD::expand()
{
  BASE_SUBCKT::expand(); // calls common->expand, attached model
  assert(_n);
  assert(common());
  const COMMON_BUILT_IN_RCD* c = static_cast<const COMMON_BUILT_IN_RCD*>(common());
  assert(c);
  assert(c->model());
  const MODEL_BUILT_IN_RCD* m = prechecked_cast<const MODEL_BUILT_IN_RCD*>(c->model());
  assert(m);
  assert(c->sdp());
  const SDP_BUILT_IN_RCD* s = prechecked_cast<const SDP_BUILT_IN_RCD*>(c->sdp());
  assert(s);
  if (!subckt()) {
    new_subckt();
  }else{
  }

  if (_sim->is_first_expand()) {
    precalc_first();
    precalc_last();
    // local nodes
    //assert(!(_n[n_ic].n_()));
    //BUG// this assert fails on a repeat elaboration after a change.
    //not sure of consequences when new_model_node called twice.
    if (!(_n[n_ic].n_())) {
      if (false) {
        _n[n_ic] = _n[n_b];
      }else{
        _n[n_ic].new_model_node("." + long_label() + ".ic", this);
      }
    }else{
      if (false) {
        assert(_n[n_ic] == _n[n_b]);
      }else{
        //_n[n_ic].new_model_node("ic." + long_label(), this);
      }
    }

    // clone subckt elements
    {
      if (!_Ccg) {
        const CARD* p = device_dispatcher["capacitor"];
        assert(p);
        _Ccg = dynamic_cast<COMPONENT*>(p->clone());
        assert(_Ccg);
        subckt()->push_front(_Ccg);
      }else{
      }
      {
        node_t nodes[] = {_n[n_ic], _n[n_b]};
        _Ccg->set_parameters("Ccg", this, NULL, 1.0, 0, NULL, 2, nodes);
      }
    }
    if (c->dummy_emit) {
      if (_Ye) {
        subckt()->erase(_Ye);
        _Ye = NULL;
      }else{
      }
    }else{
      if (!_Ye) {
        const CARD* p = device_dispatcher["admittance"];
        assert(p);
        _Ye = dynamic_cast<COMPONENT*>(p->clone());
        assert(_Ye);
        subckt()->push_front(_Ye);
      }else{
      }
      {
        node_t nodes[] = {_n[n_u], _n[n_ic]};
        _Ye->set_parameters("Ye", this, &Eval_Ye, 0, 0, NULL, 2, nodes);
      }
    }
    if (!c->dummy_emit) {
      if (_Re) {
        subckt()->erase(_Re);
        _Re = NULL;
      }else{
      }
    }else{
      if (!_Re) {
        const CARD* p = device_dispatcher["resistor"];
        assert(p);
        _Re = dynamic_cast<COMPONENT*>(p->clone());
        assert(_Re);
        subckt()->push_front(_Re);
      }else{
      }
      {
        node_t nodes[] = {_n[n_u], _n[n_ic]};
        _Re->set_parameters("Re", this, NULL, 10, 0, NULL, 2, nodes);
      }
    }
    if (!c->dummy_capture) {
      if (_Rc) {
        subckt()->erase(_Rc);
        _Rc = NULL;
      }else{
      }
    }else{
      if (!_Rc) {
        const CARD* p = device_dispatcher["resistor"];
        assert(p);
        _Rc = dynamic_cast<COMPONENT*>(p->clone());
        assert(_Rc);
        subckt()->push_front(_Rc);
      }else{
      }
      {
        node_t nodes[] = {_n[n_b], _n[n_ic]};
        _Rc->set_parameters("Rc", this, NULL, 10, 0, NULL, 2, nodes);
      }
    }
    if (c->dummy_capture) {
      if (_CRc) {
        subckt()->erase(_CRc);
        _CRc = NULL;
      }else{
      }
    }else{
      if (!_CRc) {
        const CARD* p = device_dispatcher["vcr"];
        assert(p);
        _CRc = dynamic_cast<COMPONENT*>(p->clone());
        assert(_CRc);
        subckt()->push_front(_CRc);
      }else{
      }
      {
        node_t nodes[] = {_n[n_ic], _n[n_b], _n[n_u], _n[n_b]};
        _CRc->set_parameters("CRc", this, &Eval_CRc, 0, 0, NULL, 4, nodes);
      }
    }
  }else{
    //precalc();
  }
  //precalc();
  subckt()->expand();
  //subckt()->precalc();
  assert(!is_constant());
  if ( adp() == NULL ){
    attach_adp( m->new_adp( (COMPONENT*) this ) );
  }else{
    assert(false);
  }
}
/*--------------------------------------------------------------------------*/
double DEV_BUILT_IN_RCD::tr_probe_num(const std::string& x)const
{
  assert(_n);
  const COMMON_BUILT_IN_RCD* c = prechecked_cast<const COMMON_BUILT_IN_RCD*>(common());
  assert(c);
  const MODEL_BUILT_IN_RCD* m = prechecked_cast<const MODEL_BUILT_IN_RCD*>(c->model());
  assert(m);
  const SDP_BUILT_IN_RCD* s = prechecked_cast<const SDP_BUILT_IN_RCD*>(c->sdp());
  assert(s);
  const ADP_BUILT_IN_RCD* a = prechecked_cast<const ADP_BUILT_IN_RCD*>(adp());

  if (Umatch(x, "region ")) {
    return  static_cast<double>(_region);
  }else if (Umatch(x, "vc ")) {
    return  ( _n[n_ic].v0() - _n[n_b].v0() ) * c->weight;
  }else if (Umatch(x, "v ")) {
    return  _n[n_u].v0() - _n[n_b].v0();
  }else if (Umatch(x, "status ")) {
    return  static_cast<double>(converged() * 2);
  }else if (Umatch(x, "_region ")) {
    return _region;
  }else {
    return BASE_SUBCKT::tr_probe_num(x);
  }
}
/*--------------------------------------------------------------------------*/
double DEV_BUILT_IN_RCD::tt_probe_num(const std::string& x)const
{
  assert(_n);
  const COMMON_BUILT_IN_RCD* c = prechecked_cast<const COMMON_BUILT_IN_RCD*>(common());
  assert(c);
  const MODEL_BUILT_IN_RCD* m = prechecked_cast<const MODEL_BUILT_IN_RCD*>(c->model());
  assert(m);
  const SDP_BUILT_IN_RCD* s = prechecked_cast<const SDP_BUILT_IN_RCD*>(c->sdp());
  assert(s);
  const ADP_BUILT_IN_RCD* a = prechecked_cast<const ADP_BUILT_IN_RCD*>(adp());
  if(!a)untested();

  if (Umatch(x, "vc ")) {
    return  _n[n_ic].v0() - _n[n_b].v0();
  }else {
    return BASE_SUBCKT::tt_probe_num(x);
  }
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
// cc_direct

double ADP_BUILT_IN_RCD::tt_probe_num(const std::string& x)const {untested();}
double ADP_BUILT_IN_RCD::tr_probe_num(const std::string& x)const {untested();}
void ADP_BUILT_IN_RCD::tt_accept() {}
void ADP_BUILT_IN_RCD::tt_commit() {}
void ADP_BUILT_IN_RCD::init(const COMPONENT* c)
{
}
/*--------------------------------------------------------------------------*/
ADP_CARD* MODEL_BUILT_IN_RCD::new_adp(COMPONENT* c)const
{
  assert(c);
  return MODEL_CARD::new_adp(c);
}
/*--------------------------------------------------------------------------*/
////  bool DEV_BUILT_IN_RCD::tr_needs_eval()const  // not defined...
//  {
//          untested();
//          return true;
//
//  }
///*--------------------------------------------------------------------------*/
bool DEV_BUILT_IN_RCD::tr_needs_eval()const
{
        untested();
  return true;
}
///*--------------------------------------------------------------------------*/
//
bool DEV_BUILT_IN_RCD::do_tr()
{

     untested0(long_label().c_str());
      assert(subckt());set_converged(subckt()->do_tr());return converged();

}
//
//  const COMMON_BUILT_IN_RCD* c = prechecked_cast<const COMMON_BUILT_IN_RCD*>(common());
//  assert(c);
//  const MODEL_BUILT_IN_RCD* m = prechecked_cast<const MODEL_BUILT_IN_RCD*>(c->model());
//  assert(m);
//
//  // c->tr_eval(this);
//  m->tr_eval(this);
//
//  set_converged(subckt()->do_tr());
//
//  bool co = converged();
//
//  return co;
//
//
/*--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
